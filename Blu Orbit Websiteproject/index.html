<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dolumbican Blu Orbit: Space Mission Game</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts for retro title -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* Custom styles for a retro, space-age feel */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117; /* Dark space background */
            color: #e0e0e0;
            overflow: hidden; /* Prevent scrolling */
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end; /* Align items to the bottom */
            min-height: 100vh;
        }
        canvas {
            display: block;
            background-color: transparent; /* Three.js will render against the body background */
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1; /* Below UI */
        }

        /* Main Game Title Container */
        #game-title-container {
            position: absolute;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 1000px;
            z-index: 10;
            pointer-events: none; /* Only title, no interaction */
            text-align: center;
        }
        #game-title-container h1 {
            pointer-events: auto; /* Make title text itself selectable/interactable */
        }

        /* Mission Control Message Area - positioned top-right */
        #mission-message-area {
            position: absolute;
            top: 1rem;
            right: 1rem;
            z-index: 10;
            pointer-events: auto; /* Allow interactions within message box */
            max-width: 300px; /* Constrain width */
            padding: 0.5rem; /* Padding around the message box */
        }

        #message-box {
            background-color: rgba(30, 40, 50, 0.9);
            color: #00f0ff; /* Neon blue text */
            border: 2px solid #00f0ff;
            border-radius: 0.75rem;
            padding: 0.7rem;
            text-align: left; /* Align text left */
            font-size: 0.9rem;
            font-weight: bold;
            box-shadow: 0 0 8px rgba(0, 240, 255, 0.3);
            min-height: 35px;
            display: flex;
            align-items: center;
            justify-content: flex-start; /* Align content to the start (left) */
            width: 100%; /* Take full width of its parent */
        }

        /* Health Bar Container - positioned top-left, below radar */
        #health-bar-container {
            position: absolute;
            top: 230px; /* Adjust based on fuel gauge (100px) + radar (100px) + margins */
            left: 1rem;
            pointer-events: auto;
            width: 100%;
            max-width: 200px;
            display: flex;
            justify-content: center;
            z-index: 10;
        }
        .health-notch {
            width: 30px;
            height: 15px;
            background-color: #00ff00; /* Green for full health */
            border: 1px solid #00bb00;
            margin: 0 2px;
            border-radius: 3px;
            box-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
        }
        .health-notch.damaged {
            background-color: #ffcc00; /* Yellow for damaged */
            box-shadow: 0 0 5px rgba(255, 204, 0, 0.5);
        }
        .health-notch.critical {
            background-color: #ff0000; /* Red for critical */
            box-shadow: 0 0 5px rgba(255, 0, 0, 0.7);
        }

        /* Fuel Gauge Container - positioned top-left */
        #fuel-gauge-container {
            position: absolute;
            top: 1rem;
            left: 1rem;
            z-index: 10;
            pointer-events: auto;
            width: 100px; /* Fixed width */
            height: 100px; /* Adjusted height for circle */
            background-color: rgba(30, 40, 50, 0.7);
            border: 2px solid #00f0ff;
            border-radius: 50%; /* Make it circular */
            box-shadow: 0 0 8px rgba(0, 240, 255, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 5px;
            box-sizing: border-box;
        }

        #fuel-gauge-container svg {
            width: 90%; /* Adjust SVG size within container */
            height: 90%;
            filter: drop-shadow(0 0 2px rgba(0, 240, 255, 0.5)); /* Subtle glow for the gauge */
        }

        #fuel-needle-line {
            transform-origin: 50px 50px;
            transition: transform 0.3s ease-out, stroke 0.3s ease-out;
        }

        #fuel-label {
            font-size: 8px;
            font-weight: bold;
            fill: #00f0ff;
            pointer-events: none;
        }

        #fuel-pump-icon {
            fill: #00f0ff;
        }

        /* Mini-Map Container - positioned top-left, below fuel */
        #mini-map-container {
            position: absolute;
            top: 120px; /* Below fuel gauge (100px height + 1rem top margin) */
            left: 1rem;
            z-index: 10;
            pointer-events: auto;
            width: 100px;
            height: 100px;
            background-color: rgba(30, 40, 50, 0.7);
            border: 2px solid #00f0ff;
            border-radius: 50%;
            box-shadow: 0 0 8px rgba(0, 240, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #mini-map-container svg {
            width: 90px;
            height: 90px;
        }
        #mini-map-label {
            font-size: 8px;
            font-weight: bold;
            fill: #00f0ff;
            pointer-events: none;
        }
        .map-dot {
            transition: transform 0.1s linear;
        }
        .map-dot.pulsating {
            animation: pulse-dot 1s infinite alternate;
        }
        @keyframes pulse-dot {
            from { r: 3px; }
            to { r: 5px; }
        }

        /* New Gas Icon Button Container */
        #gas-icon-container {
            position: absolute;
            bottom: 14rem; /* Adjusted position to be above joystick */
            left: 1rem;
            z-index: 10;
            pointer-events: auto;
            width: 100px; /* Fixed width */
            height: 100px; /* Adjusted height for circle */
            background-color: rgba(30, 40, 50, 0.7);
            border: 2px solid #00f0ff;
            border-radius: 50%;
            box-shadow: 0 0 8px rgba(0, 240, 255, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 5px;
            box-sizing: border-box;
            cursor: pointer;
            transition: all 0.15s ease-in-out;
        }
        #gas-icon-container:hover {
            background-color: rgba(40, 50, 60, 0.9);
            box-shadow: 0 0 12px rgba(0, 240, 255, 0.5);
            transform: translateY(-2px);
        }
        #gas-icon-container:active {
            transform: translateY(0);
            background-color: rgba(20, 30, 40, 0.9);
            box-shadow: 0 0 4px rgba(0, 240, 255, 0.2);
        }

        #gas-icon-container svg {
            width: 60%; /* Adjust SVG size within container */
            height: 60%;
            filter: drop-shadow(0 0 2px rgba(0, 240, 255, 0.5));
            margin-bottom: 5px;
        }
        #gas-icon-container .gas-label {
            font-size: 0.8rem;
            font-weight: bold;
            color: #00f0ff;
        }
        #gas-icon-container.hidden {
            display: none;
        }

        /* Control Panel Container - centered at bottom */
        #control-panel-container {
            pointer-events: auto;
            width: 100%;
            display: flex;
            justify-content: center;
            position: absolute; /* Position explicitly at bottom */
            bottom: 1rem;
            z-index: 10;
        }

        #control-panel {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            width: auto;
            max-width: 95%;
            padding: 0.5rem;
            position: relative;
        }
        .retro-button {
            background-color: rgba(0, 150, 0, 0.8);
            color: #00ff00;
            padding: 0.6rem 0.8rem;
            border-radius: 0.4rem;
            border: 2px solid #00ff00;
            cursor: pointer;
            font-size: 0.7rem;
            font-weight: bold;
            text-transform: uppercase;
            box-shadow: inset 0 0 4px rgba(0, 255, 0, 0.3), 0 0 10px rgba(0, 255, 0, 0.5);
            transition: all 0.15s ease-in-out;
            position: relative;
            overflow: hidden;
            letter-spacing: 0.05em;
            margin: 0.3rem;
        }
        .retro-button:hover {
            background-color: rgba(0, 200, 0, 0.9);
            box-shadow: inset 0 0 6px rgba(0, 255, 0, 0.5), 0 0 15px rgba(0, 255, 0, 0.7);
            transform: translateY(-1px);
        }
        .retro-button:active {
            background-color: rgba(0, 100, 0, 0.9);
            box-shadow: inset 0 0 2px rgba(0, 255, 0, 0.2), 0 0 5px rgba(0, 255, 0, 0.3);
            transform: translateY(0);
        }
        .retro-button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            opacity: 0;
            transition: width 0.2s ease, height 0.2s ease, opacity 0.2s ease;
        }
        .retro-button:active::before {
            width: 150%;
            height: 150%;
            opacity: 1;
        }

        /* Joystick controls styling */
        #joystick-controls {
            pointer-events: auto;
            position: absolute;
            bottom: 7rem;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 2rem;
            box-sizing: border-box;
            z-index: 10;
        }

        .joystick-module {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .directional-button {
            background-color: #006060;
            color: #e0e0e0;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px solid #00f0ff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 240, 255, 0.3);
            transition: all 0.1s ease-in-out;
            margin: 0.2rem;
        }

        .directional-button:hover {
            background-color: #008080;
            box-shadow: 0 0 15px rgba(0, 240, 255, 0.5);
        }

        .directional-button:active {
            background-color: #004040;
            transform: scale(0.95);
        }

        .joystick-group-vertical {
            display: flex;
            flex-direction: column;
        }

        .joystick-group-horizontal {
            display: flex;
        }

        /* Adjust positioning for joystick elements */
        #joystick-left {
            align-self: flex-end;
        }

        #joystick-right {
            align-self: flex-end;
        }

        /* Sound Control Container */
        #sound-control-container {
            position: absolute;
            top: 1rem; /* Default top position for desktop */
            left: 130px; /* Adjusted left position for desktop (next to fuel gauge) */
            z-index: 10;
            pointer-events: auto;
            display: flex;
            align-items: center;
            background-color: rgba(30, 40, 50, 0.7);
            border: 2px solid #00f0ff;
            border-radius: 0.75rem;
            box-shadow: 0 0 8px rgba(0, 240, 255, 0.3);
            padding: 0.5rem 0.75rem;
            gap: 0.5rem;
            transition: all 0.15s ease-in-out;
        }

        #sound-control-container:hover {
            background-color: rgba(40, 50, 60, 0.9);
            box-shadow: 0 0 12px rgba(0, 240, 255, 0.5);
        }

        #sound-icon {
            cursor: pointer;
            width: 30px;
            height: 30px;
            color: #00f0ff;
            transition: color 0.15s ease-in-out;
        }

        #sound-icon:hover {
            color: #00ffff;
        }

        #volume-slider {
            -webkit-appearance: none;
            width: 80px; /* Adjust width as needed */
            height: 8px;
            background: rgba(0, 240, 255, 0.3);
            outline: none;
            border-radius: 4px;
            transition: opacity .2s;
        }

        #volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #00f0ff;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 240, 255, 0.7);
            border: 2px solid #00aaff;
        }

        #volume-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #00f0ff;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 240, 255, 0.7);
            border: 2px solid #00aaff;
        }

        /* Loading Spinner */
        #loading-spinner {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 4px solid rgba(0, 240, 255, 0.3);
            border-top: 4px solid #00f0ff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            z-index: 100;
            display: none;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Startup Screen Styles */
        #startup-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #0d1117;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Press Start 2P', cursive;
            color: #00f0ff;
            text-shadow: 0 0 5px rgba(0, 240, 255, 0.5);
        }

        .game-title-1989 {
            font-size: 2.5rem;
            margin-bottom: 2rem;
            text-align: center;
            animation: flicker 1.5s infinite alternate;
        }

        @keyframes flicker {
            0% { opacity: 1; text-shadow: 0 0 5px rgba(0, 240, 255, 0.5); }
            50% { opacity: 0.9; text-shadow: 0 0 8px rgba(0, 240, 255, 0.7); }
            100% { opacity: 1; text-shadow: 0 0 5px rgba(0, 240, 255, 0.5); }
        }

        .startup-button-group {
            margin-top: 2rem;
        }

        .startup-button {
            background-color: #006060;
            color: #e0e0e0;
            padding: 1.2rem 2.5rem;
            border-radius: 0.75rem;
            border: 3px solid #00f0ff;
            font-family: 'Press Start 2P', cursive;
            font-size: 1.5rem;
            cursor: pointer;
            box-shadow: 0 0 15px rgba(0, 240, 255, 0.5);
            transition: all 0.2s ease-in-out;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .startup-button:hover {
            background-color: #008080;
            box-shadow: 0 0 25px rgba(0, 240, 255, 0.8);
            transform: translateY(-2px);
        }

        .startup-button:active {
            background-color: #004040;
            box-shadow: 0 0 5px rgba(0, 240, 255, 0.2);
            transform: translateY(0);
        }

        .copyright-text {
            position: absolute;
            bottom: 0.5rem; /* Adjusted for new order */
            font-size: 0.8rem;
            color: rgba(0, 240, 255, 0.7);
            text-align: center; /* Center the text */
            width: 100%; /* Take full width for centering */
            padding: 0 1rem; /* Add some padding */
            box-sizing: border-box;
            pointer-events: none; /* Make text non-clickable */
        }

        /* Styling for new links */
        .startup-links {
            position: absolute;
            bottom: 2rem; /* Adjusted for new order (above copyright) */
            font-size: 0.7rem;
            color: rgba(0, 240, 255, 0.7);
            text-align: center;
            width: 100%;
            padding: 0 1rem;
            box-sizing: border-box;
            display: flex;
            flex-direction: column; /* Stack links vertically */
            gap: 0.2rem; /* Small gap between links */
            pointer-events: auto; /* Make links clickable */
        }
        .startup-links a {
            color: #00ffff; /* Brighter color for links */
            text-decoration: none;
            text-shadow: 0 0 3px rgba(0, 240, 255, 0.5);
            transition: color 0.15s ease-in-out, text-shadow 0.15s ease-in-out;
        }
        .startup-links a:hover {
            color: #00ffee; /* Even brighter on hover */
            text-shadow: 0 0 8px rgba(0, 240, 255, 0.8);
            transform: translateY(-1px);
        }


        /* Responsive adjustments */
        @media (max-width: 768px) {
            #control-panel {
                gap: 0.3rem;
                padding: 0.3rem;
            }
            .retro-button {
                padding: 0.4rem 0.6rem;
                font-size: 0.55rem;
                margin: 0.2rem;
            }
            #message-box {
                font-size: 0.7rem;
                padding: 0.4rem;
                width: 90%;
            }
            #game-title-container {
                display: none; /* Hide game title on mobile */
            }
            #mission-message-area {
                top: 0.5rem;
                right: 0.5rem;
                max-width: 250px;
            }
            #fuel-gauge-container {
                width: 80px;
                height: 80px;
                top: 0.5rem;
                left: 0.5rem;
            }
            #health-bar-container {
                width: 100%;
                max-width: 150px;
                top: 190px; /* Adjusted for mobile: below radar */
                left: 0.5rem;
            }
            .health-notch {
                width: 25px;
                height: 12px;
            }
            #mini-map-container {
                width: 80px;
                height: 80px;
                top: 90px; /* Adjusted for mobile: below fuel */
                left: 0.5rem;
            }
            #mini-map-container svg {
                width: 70px;
                height: 70px;
            }
            #joystick-controls {
                bottom: 6rem;
                padding: 0 0.5rem;
            }
            .directional-button {
                width: 35px;
                height: 35px;
                font-size: 1rem;
                margin: 0.1rem;
            }
            #startup-screen .game-title-1989 {
                font-size: 1.8rem;
                letter-spacing: 0.1em;
            }
            #startup-screen .startup-button {
                padding: 1rem 2rem;
                font-size: 1.2rem;
            }
            #startup-screen .copyright-text {
                bottom: 0.5rem; /* Stays at the absolute bottom */
            }
            .startup-links {
                bottom: 4.5rem; /* Adjusted for mobile: Increased vertical space for links */
                gap: 0.7rem; /* Increased gap between individual links for better mobile readability */
            }

            /* Mobile-specific adjustments for sound control */
            #sound-control-container {
                top: auto; /* Remove top constraint */
                bottom: 11.5rem; /* Shifted up slightly for mobile */
                left: 0.5rem; /* Align to the left side */
            }
        }
    </style>
</head>
<body>
    <div id="three-container"></div>

    <!-- Startup Screen -->
    <div id="startup-screen">
        <h2 class="game-title-1989">Dolumbican Blu Orbit</h2>
        <div class="startup-button-group">
            <button id="start-mission-button" class="startup-button">Start Mission</button>
        </div>
        <!-- New Links Added Below Copyright -->
        <div class="startup-links">
            <a href="https://buymeacoffee.com/bluorbit" target="_blank" rel="noopener noreferrer">Keep Orbit In Space</a>
            <a href="https://blu-orbit.com" target="_blank" rel="noopener noreferrer">Official Website</a>
            <a href="https://Dolumbican.com" target="_blank" rel="noopener noreferrer">Mission Control</a>
        </div>
        <p class="copyright-text">© 1989 Dolumbican Studios Games. All Rights Reserved.</p>
    </div>


    <!-- New message box container -->
    <div id="mission-message-area" class="hidden">
        <div id="message-box">Awaiting Command...</div>
    </div>

    <!-- Main Game Title Container -->
    <div id="game-title-container" class="hidden">
        <h1 class="text-3xl md:text-5xl font-bold text-center text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-teal-400 drop-shadow-lg">
            Dolumbican Blu Orbit
        </h1>
    </div>

    <!-- Fuel Gauge Container -->
    <div id="fuel-gauge-container" class="hidden">
        <svg viewBox="0 0 100 100">
            <!-- Main Gauge Arc -->
            <path id="gauge-arc"
                  d="M 20 80 A 40 40 0 1 1 80 80"
                  fill="none" stroke="#00f0ff" stroke-width="3" stroke-linecap="round"/>

            <!-- Markers (adjusted for circular arc) -->
            <!-- E (Empty/Start) -->
            <text x="12" y="85" text-anchor="middle" fill="#00f0ff" font-size="8">E</text>
            <!-- 1/4 mark -->
            <text x="25" y="65" text-anchor="middle" fill="#00f0ff" font-size="8">1/4</text>
            <!-- 1/2 mark -->
            <text x="50" y="28" text-anchor="middle" fill="#00f0ff" font-size="8">1/2</text>
            <!-- 3/4 mark -->
            <text x="88" y="85" text-anchor="middle" fill="#00f0ff" font-size="8">F</text>

            <!-- Fuel Pump Icon (positioned at the bottom center of the gauge) -->
            <path id="fuel-pump-icon"
                  d="M50,70 L50,60 L55,60 L55,65 L60,65 L60,70 L50,70 Z M52.5,58 C51.5,58 50.5,59 50.5,60 L50.5,65 L49.5,65 L49.5,60 C49.5,59 48.5,58 47.5,58 L47.5,57 C48.5,57 49.5,57.5 49.5,58.5 L49.5,60 C49.5,61 50.5,62 51.5,62 Z"
                  transform="scale(0.5) translate(40, 105)"
                  />
            <circle cx="50" cy="50" r="4" fill="#00f0ff"/> <!-- Central pivot -->

            <!-- Needle/Lever (Now a simple line for explicit rotation) -->
            <line id="fuel-needle-line" x1="50" y1="50" x2="50" y2="20" stroke="#00ff00" stroke-width="2" stroke-linecap="round"/>

            <text x="50" y="95" text-anchor="middle" id="fuel-label">FUEL</text>
        </svg>
    </div>

    <!-- Mini-Map Container -->
    <div id="mini-map-container" class="hidden">
        <svg viewBox="0 0 100 100">
            <!-- Outer Ring -->
            <circle cx="50" cy="50" r="45" fill="none" stroke="#00f0ff" stroke-width="2" opacity="0.5"/>
            <!-- Inner Ring -->
            <circle cx="50" cy="50" r="25" fill="none" stroke="#00f0ff" stroke-width="1" opacity="0.3"/>
            <!-- Center Dot (Spacecraft) -->
            <circle cx="50" cy="50" r="3" fill="#ffffff"/>
            <!-- Dynamic Dots for Collectibles -->
            <g id="collectible-dots"></g>
            <text x="50" y="95" text-anchor="middle" id="mini-map-label">RADAR</text>
        </svg>
    </div>


    <div id="health-bar-container" class="hidden">
        <!-- Health notches will be dynamically added here -->
    </div>

    <!-- New Gas Icon Container -->
    <div id="gas-icon-container" class="hidden">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M18 20V8a2 2 0 0 0-2-2H8a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2z"></path>
            <path d="M12 2v4"></path>
            <path d="M9 10h6"></path>
            <path d="M9 14h6"></path>
        </svg>
        <span class="gas-label">GAS</span>
    </div>

    <div id="control-panel-container" class="hidden">
        <div id="control-panel">
            <button id="main-power-button" class="retro-button">Main Power</button>
            <button id="engine-ignite-button" class="retro-button">Ignite Engines</button>
            <button id="thrust-control-button" class="retro-button">Thrust Control</button>
            <button id="report-status-button" class="retro-button">Report Status</button>
            <button id="request-data-button" class="retro-button">Request Data</button>
        </div>
    </div>

    <div id="joystick-controls" class="hidden">
        <div id="joystick-left" class="joystick-module">
            <button id="move-up" class="directional-button">▲</button>
            <div class="joystick-group-horizontal">
                <button id="move-left" class="directional-button">◀</button>
                <button id="move-down" class="directional-button">▼</button>
            </div>
        </div>
        <div id="joystick-right" class="joystick-module">
            <!-- This is for directional control right -->
            <button id="move-right" class="directional-button">▶</button>
        </div>
    </div>

    <!-- New Sound Control Container -->
    <div id="sound-control-container" class="hidden">
        <!-- Speaker Icon (will change for mute/unmute) -->
        <svg id="sound-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-volume-2">
            <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
            <path d="M19.07 4.93a10 10 0 0 1 0 14.14M23.31 1.69a16 16 0 0 1 0 20.62"></path>
        </svg>
        <!-- Volume Slider -->
        <input type="range" id="volume-slider" min="0" max="100" value="70">
    </div>

    <!-- Loading Spinner -->
    <div id="loading-spinner"></div>

    <!-- Tone.js CDN for audio effects -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- Firebase SDKs for persistence -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global variables for Firebase instances
        let app;
        let db;
        let auth;
        let globalDistanceDocRef;
        let authReady = false; // Flag to indicate Firebase Auth is ready
        let distanceUpdateIntervalId; // To manage the interval for writing to Firestore
        let unsubscribeFromDistance; // To clean up Firestore snapshot listener

        // Ensure global variables are accessible by the rest of the script
        window.initializeApp = initializeApp;
        window.getAuth = getAuth;
        window.signInAnonymously = signInAnonymously;
        window.signInWithCustomToken = signInWithCustomToken;
        window.onAuthStateChanged = onAuthStateChanged;
        window.getFirestore = getFirestore;
        window.doc = doc;
        window.getDoc = getDoc;
        window.setDoc = setDoc;
        window.onSnapshot = onSnapshot;

        // Firebase Initialization Function
        window.initFirebase = async function() {
            const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);

            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            globalDistanceDocRef = doc(db, `artifacts/${appId}/public/data/game_state/global_distance`);

            return new Promise(resolve => {
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        console.log("Firebase Auth ready with user:", user.uid);
                        authReady = true;
                        resolve(); // Resolve the promise once auth is ready
                    } else {
                        console.log("No user signed in. Attempting anonymous sign-in or custom token.");
                        try {
                            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                                await signInWithCustomToken(auth, __initial_auth_token);
                            } else {
                                await signInAnonymously(auth);
                            }
                            console.log("Signed in to Firebase.");
                            authReady = true;
                            resolve();
                        } catch (error) {
                            console.error("Error during Firebase sign-in:", error);
                            displayMissionMessage("Error: Failed to connect to mission database. Game may not save progress.", 7000);
                            authReady = false; // Mark auth as not ready if it failed
                            resolve(); // Still resolve to allow game to proceed, but with warnings
                        }
                    }
                });
            });
        };

        // Function to fetch initial global distance from Firestore
        window.fetchInitialGlobalDistance = async function() {
            if (!authReady) {
                console.warn("Firebase Auth not ready to fetch global distance.");
                return 0; // Default to 0 if not ready
            }
            try {
                const docSnap = await getDoc(globalDistanceDocRef);
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    // Setup real-time listener after initial fetch if not already done
                    if (!unsubscribeFromDistance) {
                        setupGlobalDistanceListener();
                    }
                    return data.currentDistance || 0;
                } else {
                    console.log("Global distance document does not exist. Initializing to 0 in Firestore.");
                    await setDoc(globalDistanceDocRef, { currentDistance: 0 }); // Create it
                    // Setup real-time listener after initial creation
                    if (!unsubscribeFromDistance) {
                        setupGlobalDistanceListener();
                    }
                    return 0;
                }
            } catch (error) {
                console.error("Error fetching initial global distance:", error);
                displayMissionMessage("Error: Could not retrieve interstellar navigation data. Starting from 0 miles.", 5000);
                return 0; // Fallback to 0
            }
        };

        // Real-time listener for global distance
        window.setupGlobalDistanceListener = function() {
            if (unsubscribeFromDistance) {
                unsubscribeFromDistance(); // Clean up previous listener if any
            }
            unsubscribeFromDistance = onSnapshot(globalDistanceDocRef, (docSnap) => {
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    // Update local distanceFromEarth from Firestore. This handles updates from other clients.
                    distanceFromEarth = data.currentDistance || 0;
                    // console.log("Local distance updated from Firestore via snapshot:", distanceFromEarth);
                } else {
                    console.warn("Global distance document disappeared from Firestore.");
                    // Could re-initialize or handle as an error
                }
            }, (error) => {
                console.error("Error listening to global distance:", error);
                displayMissionMessage("Error: Real-time interstellar navigation data interrupted.", 5000);
            });
        };

        // Function to start updating global distance to Firestore periodically
        window.startGlobalDistanceUpdater = function() {
            if (distanceUpdateIntervalId) {
                clearInterval(distanceUpdateIntervalId);
            }
            const firestoreUpdateInterval = 5000; // Update every 5 seconds
            distanceUpdateIntervalId = setInterval(async () => {
                if (authReady && isFlying) { // Only write if authenticated and game is active
                    try {
                        // Use setDoc to prevent merging with other fields if any, always overwrite currentDistance
                        await setDoc(globalDistanceDocRef, { currentDistance: distanceFromEarth });
                        // console.log("Global distance saved:", distanceFromEarth);
                    } catch (error) {
                        console.error("Error saving global distance:", error);
                        // displayMissionMessage("Error: Failed to save interstellar voyage progress.", 5000);
                    }
                }
            }, firestoreUpdateInterval);
        };

        // Function to stop the periodic Firestore update
        window.stopGlobalDistanceUpdater = function() {
            if (distanceUpdateIntervalId) {
                clearInterval(distanceUpdateIntervalId);
                distanceUpdateIntervalId = null;
            }
        };
    </script>


    <script>
        // Main Three.js Scene Setup Variables
        let scene, camera, renderer;
        let bluOrbitSpaceship = null; // Represents the physical spacecraft
        let frontEngineFireParticles; // Particle system for the front of the spacecraft's engine fire
        let skybox;
        let ground;
        let planets = []; // Array to hold planet meshes (non-collectible celestial bodies)
        let asteroids = []; // Array to hold asteroid meshes
        let otherSpacecrafts = []; // Array to hold other passing spacecraft

        // Game State Variables
        let isFlying = false;
        let currentFlightSpeed = 0.0;
        const baseFlightSpeed = 0.5;
        const thrustBoostSpeed = 1.5;
        const maneuverSpeed = 0.1;

        // Movement state for joystick/keyboard
        let moveX = 0; // -1 for left, 0 for none, 1 for right
        let moveY = 0; // -1 for down, 0 for none, 1 for up

        // Spacecraft Health System
        let maxHealth = 3;
        let spacecraftHealth = maxHealth;

        // Mission Variables
        let distanceFromEarth = 0; // Will be set by Firestore
        let fuelLevel = 10000; // Starting with a good amount of fuel
        const maxFuelLevel = 10000; // Define max fuel level for gauge calculation
        const fuelConsumptionRate = 5;
        const maneuverFuelCost = 0.5;
        const thrustFuelCostMultiplier = 2;

        // Three.js Constants
        const fireParticleCount = 100;
        let frontFireParticlesData = []; // Data for front fire particle animation
        const PLAYER_COLLISION_RADIUS = 4; // Adjusted for better collision with scaled craft (half of 8-unit depth)

        // Planet/Obstacle Constants
        const PLANET_RADIUS_MIN = 5;
        const PLANET_RADIUS_MAX = 20;
        const PLANET_MIN_SPEED = 0.1;
        const PLANET_MAX_SPEED = 0.5;
        let planetSpawnRate = 1000; // Milliseconds
        let lastPlanetSpawnTime = 0;
        const PLANET_BATCH_INTERVAL = 10000; // Spawn a batch every 10 seconds
        let lastPlanetBatchTime = 0;

        // Asteroid Constants
        const ASTEROID_RADIUS_MIN = 0.5;
        const ASTEROID_RADIUS_MAX = 3;
        const ASTEROID_MIN_SPEED = 0.2;
        const ASTEROID_MAX_SPEED = 0.8;
        let asteroidSpawnRate = 200; // Milliseconds, more frequent than planets
        let lastAsteroidSpawnTime = 0;

        // Other Spacecraft Constants
        let otherSpacecraftSpawnRate = 30000; // Start with 30 seconds
        let lastOtherSpacecraftSpawnTime = 0;
        const OTHER_SPACECRAFT_SPEED_MIN = 0.1;
        const OTHER_SPACECRAFT_SPEED_MAX = 0.3;


        // Background speed control
        const skyboxSpeedMultiplier = 0.05;
        const objectMovementScale = 0.1; // General scale for how fast objects move towards us

        // UI Element References
        const messageBox = document.getElementById('message-box');
        const fuelNeedleLine = document.getElementById('fuel-needle-line');
        const healthBarContainer = document.getElementById('health-bar-container');
        const collectibleDotsGroup = document.getElementById('collectible-dots');
        const loadingSpinner = document.getElementById('loading-spinner');

        // Global references to buttons for easy access in any function
        let mainPowerButton;
        let engineIgniteButton;
        let thrustControlButton;
        let reportStatusButton;
        let requestDataButton;
        let gasIconButton; // New reference for the gas icon button
        let soundIcon; // New reference for the sound icon
        let volumeSlider; // New reference for the volume slider

        // Startup screen elements
        const startupScreen = document.getElementById('startup-screen');
        const gameTitleContainer = document.getElementById('game-title-container');
        const fuelGaugeContainer = document.getElementById('fuel-gauge-container');
        const miniMapContainer = document.getElementById('mini-map-container');
        const missionMessageArea = document.getElementById('mission-message-area');
        const healthBarContainerElement = document.getElementById('health-bar-container');
        const controlPanelContainer = document.getElementById('control-panel-container');
        const joystickControls = document.getElementById('joystick-controls');
        const startMissionButton = document.getElementById('start-mission-button');
        const soundControlContainer = document.getElementById('sound-control-container'); // New reference


        // Global var for initial time for delta calculation
        let lastFrameTime = 0; // Initialize for first frame

        // Deep Space Tiers & Thresholds (Miles)
        const TIER_1_THRESHOLD = 0; // Initial
        const TIER_2_THRESHOLD = 3; // First deep space tier, changed from 10 to 3
        const TIER_3_THRESHOLD = 1000;
        const TIER_4_THRESHOLD = 10000;
        const TIER_5_THRESHOLD = 100000; // Beyond this is truly deep space

        let currentDeepSpaceTier = 1;

        // Audio Setup
        document.documentElement.addEventListener("mousedown", () => {
          if (Tone.context.state !== 'running') {
            Tone.context.resume();
            console.log("Tone.js audio context resumed!");
          }
        });

        const distortion = new Tone.Distortion(0.5).toDestination();
        const thrustEffect = new Tone.NoiseSynth({
            noise: { type: "white" },
            envelope: { attack: 0.1, decay: 1.0, sustain: 0, release: 0.5 },
            volume: -3
        }).connect(distortion);

        const powerDownEffect = new Tone.Synth({
            oscillator: { type: "sine" },
            envelope: { attack: 0.01, decay: 0.5, sustain: 0, release: 0.1 },
            volume: -10
        }).toDestination();

        function playThrustSound() {
            thrustEffect.triggerAttackRelease("1n");
        }

        function playPowerDownSound() {
            const now = Tone.context.currentTime;
            powerDownEffect.triggerAttackRelease("C3", now, now);
        }

        // Continuous Engine Sound definition
        const continuousEngineSound = new Tone.NoiseSynth({
            noise: { type: "white" },
            envelope: {
                attack: 0.1,    // Gentle attack
                decay: 0,       // No decay phase, sustain indefinitely
                sustain: 1.0,   // Full sustain
                release: 1.0    // Gentle release
            },
            volume: -15 // Background hum, subtle volume
        }).toDestination();
        continuousEngineSound.isStarted = false; // Custom flag to track state

        // Function to start continuous engine sound
        function startContinuousEngineSound() {
            if (Tone.context.state === 'running' && !continuousEngineSound.isStarted) {
                continuousEngineSound.triggerAttack();
                continuousEngineSound.isStarted = true; // Custom flag to track state
            }
        }

        // Function to stop continuous engine sound
        function stopContinuousEngineSound() {
            if (continuousEngineSound.isStarted) {
                continuousEngineSound.triggerRelease();
                continuousEngineSound.isStarted = false; // Reset flag
            }
        }

        /**
         * Displays a message in the mission control message box.
         * @param {string} msg The message to display.
         * @param {number} durationMs Duration in milliseconds the message should be visible.
         */
        function displayMissionMessage(msg, durationMs = 3000) {
            messageBox.textContent = msg;
            missionMessageArea.classList.remove('hidden');
            clearTimeout(messageBox.hideTimeout);
            messageBox.hideTimeout = setTimeout(() => {
                missionMessageArea.classList.add('hidden');
            }, durationMs);
        }

        /**
         * Updates the visual health bar based on current health.
         */
        function updateHealthBar() {
            healthBarContainer.innerHTML = ''; // Clear existing notches
            for (let i = 0; i < maxHealth; i++) {
                const notch = document.createElement('div');
                notch.classList.add('health-notch');
                if (i >= spacecraftHealth) {
                    notch.style.backgroundColor = '#444'; // Grey for lost health
                    notch.style.boxShadow = 'none';
                } else {
                    // Dynamic coloring based on remaining health
                    if (spacecraftHealth === 3) {
                        notch.style.backgroundColor = '#00ff00'; // Green
                        notch.style.boxShadow = '0 0 5px rgba(0, 255, 0, 0.5)';
                    } else if (spacecraftHealth === 2) {
                        notch.style.backgroundColor = '#ffcc00'; // Yellow
                        notch.style.boxShadow = '0 0 5px rgba(255, 204, 0, 0.5)';
                    } else { // spacecraftHealth === 1
                        notch.style.backgroundColor = '#ff0000'; // Red
                        notch.style.boxShadow = '0 0 5px rgba(255, 0, 0, 0.7)';
                    }
                }
                healthBarContainer.appendChild(notch);
            }
        }

        /**
         * Updates the fuel gauge needle rotation.
         */
        function updateFuelGauge() {
            const fuelPercentage = fuelLevel / maxFuelLevel;
            // Angle from 0 degrees (full) to -180 degrees (empty) for a semi-circle dial
            // SVG's default 0 degrees is to the right, so 135 degrees is "full" and -45 degrees is "empty"
            // For a needle that goes from bottom-left (full) to bottom-right (empty) through top:
            // Full is 135 deg, Empty is -45 deg. Total range 180 degrees.
            const rotationDegrees = 135 - (fuelPercentage * 180); // Adjust range if needed
            fuelNeedleLine.style.transform = `rotate(${rotationDegrees}deg)`;

            // Change needle color based on fuel level
            if (fuelPercentage > 0.5) {
                fuelNeedleLine.style.stroke = '#00ff00'; // Green
            } else if (fuelPercentage > 0.2) {
                fuelNeedleLine.style.stroke = '#ffcc00'; // Yellow
            } else {
                fuelNeedleLine.style.stroke = '#ff0000'; // Red
            }
        }

        /**
         * Updates the mini-map with planet and asteroid positions.
         * Assumes a fixed mini-map size (e.g., 90x90 in SVG viewBox 0 0 100 100).
         */
        function updateMiniMap() {
            collectibleDotsGroup.innerHTML = ''; // Clear old dots

            const mapSize = 90; // SVG internal size
            const mapCenter = 50; // SVG center

            // Map the game world's X and Y range to the mini-map's X and Y range
            const worldRange = 1000; // Max distance to display objects on map
            const scale = mapSize / (worldRange * 2);

            let playerPosition = new THREE.Vector3();
            // In this setup, bluOrbitSpaceship is at (0,0,0) and the camera moves,
            // so player position relative to the world origin is effectively (0,0,0) for radar.
            // Objects moving past the camera/ship.

            // Display planets on map
            planets.forEach(planet => {
                const relativeX = planet.position.x;
                const relativeZ = planet.position.z; // Using Z for vertical on map, simulating "distance"

                if (Math.abs(relativeX) < worldRange && Math.abs(relativeZ) < worldRange) {
                    const mapX = mapCenter + (relativeX * scale);
                    const mapY = mapCenter + (relativeZ * scale);

                    const dot = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    dot.setAttribute('cx', mapX);
                    dot.setAttribute('cy', mapY);
                    dot.setAttribute('r', 3);
                    dot.setAttribute('fill', '#00ffff'); // Cyan for planets
                    dot.classList.add('map-dot');
                    collectibleDotsGroup.appendChild(dot);
                }
            });

            // Display asteroids on map (smaller dots)
            asteroids.forEach(asteroid => {
                const relativeX = asteroid.position.x;
                const relativeZ = asteroid.position.z;

                if (Math.abs(relativeX) < worldRange && Math.abs(relativeZ) < worldRange) {
                    const mapX = mapCenter + (relativeX * scale);
                    const mapY = mapCenter + (relativeZ * scale);

                    const dot = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    dot.setAttribute('cx', mapX);
                    dot.setAttribute('cy', mapY);
                    dot.setAttribute('r', 1.5); // Smaller radius for asteroids
                    dot.setAttribute('fill', '#aaaaaa'); // Grey for asteroids
                    dot.classList.add('map-dot');
                    collectibleDotsGroup.appendChild(dot);
                }
            });

            // Display other spacecraft on map (even smaller dots, different color)
            otherSpacecrafts.forEach(ship => {
                const relativeX = ship.position.x;
                const relativeZ = ship.position.z;

                if (Math.abs(relativeX) < worldRange && Math.abs(relativeZ) < worldRange) {
                    const mapX = mapCenter + (relativeX * scale);
                    const mapY = mapCenter + (relativeZ * scale);

                    const dot = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    dot.setAttribute('cx', mapX);
                    dot.setAttribute('cy', mapY);
                    dot.setAttribute('r', 2); // Slightly larger than asteroid, smaller than planet
                    dot.setAttribute('fill', '#ff00ff'); // Magenta for other spacecraft
                    dot.classList.add('map-dot');
                    collectibleDotsGroup.appendChild(dot);
                }
            });
        }

        /**
         * Creates a new planet with random position, size, and speed, influenced by deep space tier.
         */
        function createPlanetObject() {
            const baseRadius = THREE.MathUtils.randFloat(PLANET_RADIUS_MIN, PLANET_RADIUS_MAX);
            let planetColor = new THREE.Color();
            let planetType = 'rocky'; // Default

            // Dynamic planet appearance based on distance
            if (distanceFromEarth < TIER_2_THRESHOLD) {
                // Initial tier
                const planetTypes = [
                    { radius: 50, color: 0x8B4513, type: 'rocky'}, // Saddle Brown
                    { radius: 70, color: 0x4682B4, type: 'gas'}, // Steel Blue
                    { radius: 40, color: 0xADD8E6, type: 'ice'}, // Light Blue
                    { radius: 60, color: 0x773333, type: 'rocky'}, // Darker Red-Brown
                    { radius: 80, color: 0x8A2BE2, type: 'gas'}, // Blue Violet
                    { radius: 35, color: 0xF0E68C, type: 'rocky'} // Khaki
                ];
                const data = planetTypes[Math.floor(Math.random() * planetTypes.length)];
                planetColor.setHex(data.color);
                planetType = data.type;
            } else if (distanceFromEarth < TIER_3_THRESHOLD) {
                // Tier 2: More vibrant, slightly alien colors (e.g., purple and green as requested)
                const tier2Colors = [0x9900FF, 0x00CCFF, 0xFF6600, 0x33FF33, 0xAA00AA, 0x00EE00]; // Purple, light blue, orange, lime green, darker purple, brighter green
                planetColor.setHex(tier2Colors[Math.floor(Math.random() * tier2Colors.length)]);
                planetType = Math.random() < 0.5 ? 'gas' : 'rocky'; // More gas giants
            } else if (distanceFromEarth < TIER_4_THRESHOLD) {
                // Tier 3: Exotic, darker or glowing colors
                const tier3Colors = [0xCC00CC, 0x00FF99, 0xFF3333, 0x33CCFF]; // Magenta, aquamarine, bright red, light blue
                planetColor.setHex(tier3Colors[Math.floor(Math.random() * tier3Colors.length)]);
                planetType = Math.random() < 0.7 ? 'gas' : 'ice'; // Even more gas/ice
            } else {
                // Tier 4+: Deep space, mysterious colors, more ice/gas
                const tier4Colors = [0x550055, 0x003366, 0x88FFCC, 0xFFFFFF]; // Deep purple, deep blue, mint green, white (icy)
                planetColor.setHex(tier4Colors[Math.floor(Math.random() * tier4Colors.length)]);
                planetType = Math.random() < 0.8 ? 'ice' : 'gas'; // Predominantly ice/gas
            }

            const planet = createPlanet(baseRadius + (Math.random() * 20 - 10), planetColor.getHex(), planetType);
            planet.radius = baseRadius; // Store radius for collision detection

            // Spawn far away in Z, with random X and Y spread
            const spawnX = THREE.MathUtils.randFloatSpread(1000);
            const spawnY = THREE.MathUtils.randFloatSpread(1000);
            const spawnZ = -1500 - Math.random() * 2000; // Spawn much further away

            planet.position.set(spawnX, spawnY, spawnZ);
            planet.velocity = THREE.MathUtils.randFloat(PLANET_MIN_SPEED, PLANET_MAX_SPEED);
            planet.rotationSpeed = new THREE.Vector3(
                THREE.MathUtils.randFloat(-0.005, 0.005),
                THREE.MathUtils.randFloat(-0.005, 0.005),
                THREE.MathUtils.randFloat(-0.005, 0.005)
            );

            planets.push(planet);
            scene.add(planet);
        }

        /**
         * Creates a new asteroid with random position, size, and speed.
         */
        function createAsteroidObject() {
            const radius = THREE.MathUtils.randFloat(ASTEROID_RADIUS_MIN, ASTEROID_RADIUS_MAX);
            const detail = 0; // Low detail for simple asteroid look
            let asteroidColor = 0x555555; // Default dark grey

            // Dynamic asteroid appearance based on distance
            if (distanceFromEarth >= TIER_3_THRESHOLD) {
                // Deeper space, asteroids might have hints of crystal or unusual materials
                const deepSpaceAsteroidColors = [0x888888, 0xAAAAAA, 0xCCFFCC, 0xFFCCFF]; // Grey, light grey, pale green, pale pink
                asteroidColor = deepSpaceAsteroidColors[Math.floor(Math.random() * deepSpaceAsteroidColors.length)];
            }

            const asteroidGeometry = new THREE.DodecahedronGeometry(radius, detail); // More natural rocky shape
            const asteroidMaterial = new THREE.MeshStandardMaterial({
                color: asteroidColor, // Dynamic color
                metalness: 0.1,
                roughness: 0.9
            });
            const asteroid = new THREE.Mesh(asteroidGeometry, asteroidMaterial);

            asteroid.radius = radius; // Store radius for collision detection

            // Spawn relatively close to the player, scattered in X, Y, and Z
            const spawnX = THREE.MathUtils.randFloatSpread(200); // Spread around current X
            const spawnY = THREE.MathUtils.randFloatSpread(200); // Spread around current Y
            const spawnZ = -300 - Math.random() * 500; // Spawn in front of the player

            asteroid.position.set(bluOrbitSpaceship.position.x + spawnX, bluOrbitSpaceship.position.y + spawnY, bluOrbitSpaceship.position.z + spawnZ);
            asteroid.velocity = THREE.MathUtils.randFloat(ASTEROID_MIN_SPEED, ASTEROID_MAX_SPEED);
            asteroid.rotationSpeed = new THREE.Vector3(
                THREE.MathUtils.randFloat(-0.05, 0.05),
                THREE.MathUtils.randFloat(-0.05, 0.05),
                THREE.MathUtils.randFloat(-0.05, 0.05)
            );

            asteroids.push(asteroid);
            scene.add(asteroid);
        }

        /**
         * Creates a new 'other spacecraft' object.
         */
        function createOtherSpacecraft() {
            const type = Math.floor(Math.random() * 3); // 0: friendly, 1: alien scout, 2: derelict
            let shipMesh;
            let shipColor = new THREE.Color();
            let shipScale = 1;

            if (type === 0) { // Friendly/Exploration Vessel
                const geometry = new THREE.BoxGeometry(2, 1, 4); // Simple rectangular ship
                shipColor.setHex(0x00FF00); // Green
                shipMesh = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({ color: shipColor }));
                shipScale = 0.5;
            } else if (type === 1) { // Alien Scout
                const geometry = new THREE.ConeGeometry(1.5, 3, 8); // Cone shape
                shipColor.setHex(0xFF00FF); // Magenta
                shipMesh = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({ color: shipColor }));
                shipScale = 0.4;
                shipMesh.rotation.x = Math.PI / 2; // Point cone forward
            } else { // Derelict (damaged-looking)
                const geometry = new THREE.BoxGeometry(3, 1.5, 5);
                shipColor.setHex(0x884444); // Rusty red
                const material = new THREE.MeshStandardMaterial({ color: shipColor });
                shipMesh = new THREE.Mesh(geometry, material);
                shipScale = 0.6;
                shipMesh.rotation.z = Math.random() * Math.PI * 2; // Tilted
                shipMesh.rotation.y = Math.random() * Math.PI * 2; // Random rotation
            }

            shipMesh.scale.set(shipScale, shipScale, shipScale);

            // Spawn significantly off-axis or far away laterally
            const spawnX = THREE.MathUtils.randFloatSpread(500); // Wide lateral spread
            const spawnY = THREE.MathUtils.randFloatSpread(500);
            const spawnZ = -2000 - Math.random() * 3000; // Very far away in Z

            shipMesh.position.set(bluOrbitSpaceship.position.x + spawnX, bluOrbitSpaceship.position.y + spawnY, bluOrbitSpaceship.position.z + spawnZ);
            shipMesh.velocity = THREE.MathUtils.randFloat(OTHER_SPACECRAFT_SPEED_MIN, OTHER_SPACECRAFT_SPEED_MAX);
            shipMesh.rotationSpeed = new THREE.Vector3(
                THREE.MathUtils.randFloat(-0.01, 0.01),
                THREE.MathUtils.randFloat(-0.01, 0.01),
                THREE.MathUtils.randFloat(-0.01, 0.01)
            );

            otherSpacecrafts.push(shipMesh);
            scene.add(shipMesh);
        }


        /**
         * Updates game state: movement, fuel, health, planet/asteroid positions, and checks collisions.
         * @param {number} deltaTime - Time elapsed since last frame in milliseconds.
         */
        function updateGameLogic(deltaTime) {
            if (!isFlying) {
                // If not flying, ensure gas icon visibility is updated only if fuel is depleted
                updateGasIconVisibility();
                return;
            }

            // --- Deep Space Tier Management and Environmental Effects ---
            const oldTier = currentDeepSpaceTier;
            if (distanceFromEarth < TIER_2_THRESHOLD) {
                currentDeepSpaceTier = 1;
            } else if (distanceFromEarth < TIER_3_THRESHOLD) {
                currentDeepSpaceTier = 2;
            } else if (distanceFromEarth < TIER_4_THRESHOLD) {
                currentDeepSpaceTier = 3;
            } else if (distanceFromEarth < TIER_5_THRESHOLD) {
                currentDeepSpaceTier = 4;
            } else {
                currentDeepSpaceTier = 5; // Truly deep space
            }

            if (currentDeepSpaceTier !== oldTier) {
                console.log(`Entering Deep Space Tier ${currentDeepSpaceTier}! Distance: ${distanceFromEarth.toLocaleString()} miles`);
                // Trigger messages or visual shifts on tier change
                if (currentDeepSpaceTier === 2) {
                    displayMissionMessage("Entering Outer Reaches: Subtly shifting stellar formations detected.", 5000);
                } else if (currentDeepSpaceTier === 3) {
                    displayMissionMessage("Navigating uncharted sectors. Expect unusual celestial phenomena.", 5000);
                } else if (currentDeepSpaceTier === 4) {
                    displayMissionMessage("Deep Space Sector: Anomalous energy signatures increasing.", 5000);
                } else if (currentDeepSpaceTier === 5) {
                    displayMissionMessage("Beyond known space. Prepare for unpredictable cosmic events.", 5000);
                }

                // Update background and starfield
                updateDeepSpaceBackground(currentDeepSpaceTier);
                // Adjust fog based on tier
                updateDeepSpaceFog(currentDeepSpaceTier);
            }

            // Consume fuel
            fuelLevel -= fuelConsumptionRate;
            if (currentFlightSpeed === thrustBoostSpeed) {
                fuelLevel -= fuelConsumptionRate * (thrustFuelCostMultiplier - 1);
            }
            fuelLevel = Math.max(0, fuelLevel); // Don't go below 0
            updateFuelGauge();
            updateGasIconVisibility(); // Update gas icon visibility based on current fuel

            if (fuelLevel <= 0 && isFlying) { // If fuel depleted AND currently flying
                isFlying = false; // Force immediate shutdown
                currentFlightSpeed = 0;
                stopContinuousEngineSound(); // Stop engine sound immediately
                displayMissionMessage("CRITICAL: Fuel Depleted! Spacecraft systems shutting down. Use the GAS icon to refuel, then press Main Power to restart.", 5000); // Updated message
                mainPowerButton.textContent = "Power: OFF"; // Update button text to reflect off state
                engineIgniteButton.textContent = "Ignite Engines"; // Reset ignite button text
                thrustControlButton.textContent = "Thrust: OFF"; // Reset thrust button text
                if (frontEngineFireParticles) { frontEngineFireParticles.material.opacity = 0.0; }
                // No need to explicitly save distance here for fuel depletion, as interval saver handles it.
                stopGlobalDistanceUpdater(); // Stop updating distance if game pauses
                return; // Stop further game logic until reactivated
            }


            // Move spacecraft (camera is attached to it or follows it for main view)
            const deltaX = moveX * maneuverSpeed;
            const deltaY = moveY * maneuverSpeed;

            // Move the spacecraft itself (since camera is now fixed relative to it for posterior view)
            bluOrbitSpaceship.position.x += deltaX;
            bluOrbitSpaceship.position.y += deltaY;

            // Clamp spacecraft position within a reasonable range
            bluOrbitSpaceship.position.x = Math.max(-50, Math.min(50, bluOrbitSpaceship.position.x));
            bluOrbitSpaceship.position.y = Math.max(-50, Math.min(50, bluOrbitSpaceship.position.y));


            // Make ground recede
            if (ground && ground.visible) {
                ground.position.z += currentFlightSpeed * objectMovementScale; // Adjust multiplier for desired speed
                if (ground.position.z > 50) { // If ground has moved "back" relative to the ship (which is at 0,0,0)
                    ground.visible = false;
                }
            }


            // Update distance from Earth (now increasing)
            // 1 mile per minute at base speed (0.5 units)
            // = 1/60 miles per second
            // = 1 / (60 * 1000) miles per millisecond = 1 / 60000 miles/ms
            // At currentFlightSpeed (e.g., 0.5), we want (0.5 * X) miles/ms = 1/60000
            // X = (1/60000) / 0.5 = 1 / 30000 miles per unit speed per millisecond
            const milesPerUnitSpeedPerMs = 1 / 30000;
            distanceFromEarth += currentFlightSpeed * milesPerUnitSpeedPerMs * deltaTime;
            displayMissionMessage(`Miles from Earth: ${distanceFromEarth.toLocaleString(undefined, { maximumFractionDigits: 0 })} miles`);

            // No game over on distance to Earth since we are moving away
            // if (distanceToEarth <= 0) {
            //     displayMissionMessage("MISSION COMPLETE! Welcome to Earth!", 10000);
            //     gameOver();
            //     return;
            // }

            // Update planet positions and check collisions
            for (let i = planets.length - 1; i >= 0; i--) {
                const planet = planets[i];
                // Move planet forward relative to spacecraft's apparent movement
                planet.position.z += planet.velocity + (currentFlightSpeed * objectMovementScale); // Planets move towards the camera
                planet.rotation.x += planet.rotationSpeed.x;
                planet.rotation.y += planet.rotationSpeed.y;
                planet.rotation.z += planet.rotationSpeed.z;

                // Despawn if out of view (past the spacecraft by a certain amount)
                if (planet.position.z > (bluOrbitSpaceship.position.z + 50)) {
                    scene.remove(planet);
                    planets.splice(i, 1);
                }

                // Collision detection with planets (more severe)
                const distance = bluOrbitSpaceship.position.distanceTo(planet.position);
                if (distance < (PLAYER_COLLISION_RADIUS + planet.radius)) {
                    handleCollision(planet, "planet"); // Pass type for different damage
                    return;
                }
            }

            // Update asteroid positions and check collisions
            for (let i = asteroids.length - 1; i >= 0; i--) {
                const asteroid = asteroids[i];
                // Asteroids also move relative to spacecraft's apparent movement
                asteroid.position.z += asteroid.velocity + (currentFlightSpeed * objectMovementScale * 1.5); // Asteroids move faster
                asteroid.rotation.x += asteroid.rotationSpeed.x;
                asteroid.rotation.y += asteroid.rotationSpeed.y;
                asteroid.rotation.z += asteroid.rotationSpeed.z;

                // Despawn if out of view
                if (asteroid.position.z > (bluOrbitSpaceship.position.z + 20)) { // Closer despawn for asteroids
                    scene.remove(asteroid);
                    asteroids.splice(i, 1);
                }

                // Collision detection with asteroids (less severe than planets)
                const distance = bluOrbitSpaceship.position.distanceTo(asteroid.position);
                if (distance < (PLAYER_COLLISION_RADIUS + asteroid.radius)) {
                    handleCollision(asteroid, "asteroid"); // Pass type for different damage
                    return;
                }
            }

            // Update other spacecraft positions
            for (let i = otherSpacecrafts.length - 1; i >= 0; i--) {
                const ship = otherSpacecrafts[i];
                ship.position.z += ship.velocity + (currentFlightSpeed * objectMovementScale * 0.5); // Move relative to player, slower than obstacles
                ship.rotation.x += ship.rotationSpeed.x;
                ship.rotation.y += ship.rotationSpeed.y;
                ship.rotation.z += ship.rotationSpeed.z;

                // Despawn if out of view
                if (ship.position.z > (bluOrbitSpaceship.position.z + 50)) { // Despawn when they pass
                    scene.remove(ship);
                    otherSpacecrafts.splice(i, 1);
                }
            }


            // Spawn new planets
            const now = performance.now();
            if (now - lastPlanetSpawnTime > planetSpawnRate) {
                createPlanetObject();
                lastPlanetSpawnTime = now;
                planetSpawnRate = Math.max(500, planetSpawnRate * 0.99); // Increase difficulty
            }
            if (now - lastPlanetBatchTime > PLANET_BATCH_INTERVAL) {
                for (let i = 0; i < 3; i++) { createPlanetObject(); } // Spawn a few at once
                lastPlanetBatchTime = now;
            }

            // Spawn new asteroids
            if (now - lastAsteroidSpawnTime > asteroidSpawnRate) {
                createAsteroidObject();
                lastAsteroidSpawnTime = now;
                asteroidSpawnRate = Math.max(100, asteroidSpawnRate * 0.99); // Increase difficulty
            }

            // Spawn other spacecraft based on deep space tier
            if (distanceFromEarth >= TIER_2_THRESHOLD && (now - lastOtherSpacecraftSpawnTime > otherSpacecraftSpawnRate)) {
                if (Math.random() < getSpacecraftSpawnChance(currentDeepSpaceTier)) { // Probabilistic spawning
                    createOtherSpacecraft();
                    lastOtherSpacecraftSpawnTime = now;
                    otherSpacecraftSpawnRate = Math.max(10000, otherSpacecraftSpawnRate * 0.95); // Increase frequency
                }
            }


            // Update fire particles for the main spacecraft
            if (frontEngineFireParticles && bluOrbitSpaceship) {
                // Main box length is 8, so front is at +4.
                updateFireParticles(frontEngineFireParticles, frontFireParticlesData, 4, true); // Pass true for front fire
            }

            updateMiniMap();
        }

        /**
         * Determines the chance of spawning another spacecraft based on the current deep space tier.
         * @param {number} tier
         * @returns {number} Probability (0-1)
         */
        function getSpacecraftSpawnChance(tier) {
            switch (tier) {
                case 2: return 0.2; // 20% chance
                case 3: return 0.4; // 40% chance
                case 4: return 0.6; // 60% chance
                case 5: return 0.8; // 80% chance
                default: return 0;
            }
        }

        /**
         * Updates the background (skybox color, nebula properties) based on deep space tier.
         * @param {number} tier
         */
        function updateDeepSpaceBackground(tier) {
            // Adjust skybox color
            let newSkyboxColor;
            let newStarColor = 0xFFFFFF; // Default star color
            let newStarDensity = 1500; // Default star count

            switch (tier) {
                case 1:
                    newSkyboxColor = 0x02020a; // Near Earth
                    newStarColor = 0xFFFFFF;
                    newStarDensity = 1500;
                    break;
                case 2:
                    newSkyboxColor = 0x010105; // Slightly deeper, more subtle blues
                    newStarColor = 0xAAAAFF; // Hints of blue
                    newStarDensity = 2000; // Slightly denser
                    break;
                case 3:
                    newSkyboxColor = 0x0A020A; // Purpleish deep space
                    newStarColor = 0xFFFFCC; // Yellowish stars
                    newStarDensity = 2500; // Denser
                    break;
                case 4:
                    newSkyboxColor = 0x020A0A; // Tealish deep space
                    newStarColor = 0xFF88FF; // Pinkish stars
                    newStarDensity = 3000; // Even denser
                    break;
                case 5:
                    newSkyboxColor = 0x000000; // Pure black, very sparse or very dense pockets
                    newStarColor = 0x33FFFF; // Cyan stars
                    newStarDensity = 4000; // Max density, can be very clustered.
                    break;
            }

            // Smoothly interpolate skybox color
            // This requires modifying the material, but it's a dynamic change, not structural.
            // For a basic material, color change is direct.
            skybox.material.color.setHex(newSkyboxColor);

            // Re-create stars/nebulas for proper density/color changes (or modify existing if possible)
            // For simplicity, let's keep the existing stars/nebulas and just update their color if material allows.
            // Recreating is heavy, so we will try to update properties.
            // For stars, it's a single PointsMaterial, so we can change its color.
            // For nebulas, they are individual meshes. We can filter and update them or spawn new ones at this tier
            // We'll update the global star color for now, and rely on `createPlanetObject` to handle nebula/planet colors.
            // Note: Directly changing existing star positions/count in a `Points` object is complex.
            // We'll stick to color changes for existing skybox stars.
            scene.traverse((object) => {
                if (object.isPoints && object.parent === skybox) { // Check if it's our stars
                    object.material.color.setHex(newStarColor);
                }
            });
            // Nebula colors are handled by their creation, if new ones are spawned based on distance, they will pick up the new colors.
        }

        /**
         * Updates environmental fog based on deep space tier.
         * @param {number} tier
         */
        function updateDeepSpaceFog(tier) {
            // Remove existing fog if any
            if (scene.fog) {
                scene.fog = null;
            }

            let fogColor = 0x000000; // Default black
            let fogDensity = 0; // Default no fog

            switch (tier) {
                case 1:
                case 2:
                    // No significant fog near initial stages
                    break;
                case 3:
                    // Light blueish haze for distant nebulas
                    fogColor = 0x000022; // Very dark blue
                    fogDensity = 0.0005; // Subtle
                    break;
                case 4:
                    // Denser purple haze
                    fogColor = 0x110011; // Dark purple
                    fogDensity = 0.001; // Moderate
                    break;
                case 5:
                    // Very deep, potentially disorienting red/black fog or extremely clear.
                    // Let's make it a dense, dark red for "unknown" feel.
                    fogColor = 0x110000; // Very dark red
                    fogDensity = 0.002; // Quite dense
                    break;
            }

            if (fogDensity > 0) {
                scene.fog = new THREE.FogExp2(fogColor, fogDensity);
            }
        }


        /**
         * Main animation loop.
         * @param {DOMHighResTimeStamp} currentTime - The current time in milliseconds.
         */
        function animate(currentTime) {
            if (!lastFrameTime) lastFrameTime = currentTime; // Initialize lastFrameTime on first call

            const deltaTime = currentTime - lastFrameTime; // Milliseconds since last frame
            lastFrameTime = currentTime;

            requestAnimationFrameId = requestAnimationFrame(animate);

            updateGameLogic(deltaTime); // Pass deltaTime to game logic

            renderer.render(scene, camera);
        }

        /**
         * Game Over sequence.
         */
        async function gameOver() { // Made async to await Firestore save
            console.log("Game Over initiated.");
            isFlying = false;
            currentFlightSpeed = 0;

            // --- IMPORTANT: Save current distance to Firestore before game over ---
            if (window.authReady && window.globalDistanceDocRef) {
                try {
                    await window.setDoc(window.globalDistanceDocRef, { currentDistance: distanceFromEarth });
                    console.log("Final global distance saved on game over:", distanceFromEarth);
                } catch (error) {
                    console.error("Error saving final global distance on game over:", error);
                }
            }
            // --- End of critical save ---

            if (requestAnimationFrameId) {
                cancelAnimationFrame(requestAnimationFrameId); // Stop the animation loop
                requestAnimationFrameId = null; // Reset the ID
            }
            stopGlobalDistanceUpdater(); // Stop writing to Firestore on game over
            stopContinuousEngineSound(); // Ensure engine sound stops on game over

            displayMissionMessage("GAME OVER! Mission Failed. Initiating return to base.", 5000);
            setTimeout(() => {
                // Hide all game UI elements
                gameTitleContainer.classList.add('hidden');
                fuelGaugeContainer.classList.add('hidden');
                miniMapContainer.classList.add('hidden');
                missionMessageArea.classList.add('hidden');
                healthBarContainerElement.classList.add('hidden');
                controlPanelContainer.classList.add('hidden');
                joystickControls.classList.add('hidden');
                gasIconButton.classList.add('hidden'); // Hide gas icon on game over
                soundControlContainer.classList.add('hidden'); // Hide sound control on game over


                // Clear ONLY dynamic elements from the scene
                planets.forEach(p => scene.remove(p));
                planets = []; // Clear array
                asteroids.forEach(a => scene.remove(a));
                asteroids = []; // Clear array
                otherSpacecrafts.forEach(s => scene.remove(s));
                otherSpacecrafts = []; // Clear array

                // Hide the spacecraft and fire effects temporarily, don't null them
                if (bluOrbitSpaceship) {
                    bluOrbitSpaceship.visible = false;
                    if (frontEngineFireParticles) frontEngineFireParticles.material.opacity = 0.0;
                }

                // Show startup screen after game over
                startupScreen.style.display = 'flex';

            }, 3000); // Wait for mission fail message to clear
        }

        /**
         * Updates the visibility of the GAS icon based on fuel level and flight status.
         */
        function updateGasIconVisibility() {
            if (fuelLevel <= 0 && !isFlying) {
                gasIconButton.classList.remove('hidden');
            } else {
                gasIconButton.classList.add('hidden');
            }
        }

        // New: Sound Control variables
        let isMuted = false;
        let lastVolume = 0.7; // Store last non-muted volume (0-1 range for slider value)

        /**
         * Updates the sound icon based on mute state.
         */
        function updateSoundIcon() {
            if (isMuted || Tone.Destination.volume.value <= -40) { // Consider very low volume as muted visually
                soundIcon.innerHTML = `<path d="M11 5 6 9 2 9 2 15 6 15 11 19 11 5zM22 12h-4"></path>`; // Muted icon
                volumeSlider.value = 0; // Set slider to 0 if muted
            } else if (Tone.Destination.volume.value < -20) {
                soundIcon.innerHTML = `<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>`; // Volume 1 icon
            } else {
                soundIcon.innerHTML = `<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M23.31 1.69a16 16 0 0 1 0 20.62"></path>`; // Volume 2 icon
            }
        }


        /**
         * Initializes and sets up all event listeners for UI elements.
         */
        function setupUIEventListeners() {
            mainPowerButton = document.getElementById('main-power-button');
            engineIgniteButton = document.getElementById('engine-ignite-button');
            thrustControlButton = document.getElementById('thrust-control-button');
            reportStatusButton = document.getElementById('report-status-button');
            requestDataButton = document.getElementById('request-data-button');
            gasIconButton = document.getElementById('gas-icon-container'); // Get reference to new gas icon
            soundIcon = document.getElementById('sound-icon'); // Get reference to sound icon
            volumeSlider = document.getElementById('volume-slider'); // Get reference to volume slider

            startMissionButton.addEventListener('click', async () => {
                startupScreen.style.display = 'none'; // Hide startup screen
                await startGame(); // Start the game when the button is clicked, wait for it
            });

            // Joystick buttons
            const moveUp = document.getElementById('move-up');
            const moveDown = document.getElementById('move-down');
            const moveLeft = document.getElementById('move-left');
            const moveRight = document.getElementById('move-right');

            mainPowerButton.addEventListener('click', () => {
                if (isFlying) {
                    isFlying = false;
                    currentFlightSpeed = 0;
                    displayMissionMessage("Main Power OFF. All systems dormant.", 3000);
                    playPowerDownSound();
                    mainPowerButton.textContent = "Power: OFF"; // Changed for clarity
                    if (frontEngineFireParticles) { frontEngineFireParticles.material.opacity = 0.0; }
                    stopGlobalDistanceUpdater(); // Stop updating distance if game pauses
                    updateGasIconVisibility(); // Check if gas icon should appear after shutdown
                } else {
                    // Only switch to ON if fuel is not depleted
                    if (fuelLevel <= 0) {
                        displayMissionMessage("FUEL CRITICAL! Use the GAS icon to replenish fuel to proceed.", 5000);
                        return; // Do not start flight
                    }

                    isFlying = true;
                    currentFlightSpeed = baseFlightSpeed;
                    displayMissionMessage("Main Power ON. Systems nominal.", 3000);
                    startContinuousEngineSound(); // Play continuous engine sound on power up
                    mainPowerButton.textContent = "Power: ON"; // Changed for clarity
                    // No automatic refuel here, that's for the GAS icon now
                    if (frontEngineFireParticles) { frontEngineFireParticles.material.opacity = 0.8; }
                    startGlobalDistanceUpdater(); // Start updating distance if game resumes
                    updateGasIconVisibility(); // Hide gas icon if powering on
                }
            });

            engineIgniteButton.addEventListener('click', () => {
                // If not already flying, pressing ignite should effectively 'turn on' the systems
                // as a backup to main power, but without resetting the scene.
                if (!isFlying) {
                    if (fuelLevel <= 0) {
                        displayMissionMessage("FUEL CRITICAL! Use the GAS icon to replenish fuel to proceed.", 5000);
                        return;
                    }
                    isFlying = true;
                    currentFlightSpeed = baseFlightSpeed;
                    displayMissionMessage("Engines Ignited! Blu Orbit is Go!", 4000);
                    startContinuousEngineSound(); // Play continuous engine sound
                    if (frontEngineFireParticles) { frontEngineFireParticles.material.opacity = 0.8; }
                    mainPowerButton.textContent = "Power: ON"; // Align main power button state
                    startGlobalDistanceUpdater(); // Start updater if not already running
                    updateGasIconVisibility(); // Hide gas icon if powering on
                } else {
                    displayMissionMessage("Engines already ignited.", 2000);
                }
            });

            thrustControlButton.addEventListener('click', () => {
                if (!isFlying) {
                    displayMissionMessage("Engines must be ignited first!", 2000);
                    return;
                }
                if (currentFlightSpeed === baseFlightSpeed) {
                    currentFlightSpeed = thrustBoostSpeed;
                    displayMissionMessage("Thrust engaged! Maximizing speed.", 3000);
                    thrustControlButton.textContent = "Thrust: OFF"; // Changed for clarity
                    playThrustSound(); // Play thrust burst sound
                } else {
                    currentFlightSpeed = baseFlightSpeed;
                    displayMissionMessage("Thrust disengaged. Conserving fuel.", 3000);
                    thrustControlButton.textContent = "Thrust: ON"; // Changed for clarity
                    // Only play power down sound if it's explicitly turning something off, not just changing thrust.
                    // playPowerDownSound(); // Removed as it doesn't fit 'thrust disengaged'
                }
            });

            // New: Gas Icon click listener
            gasIconButton.addEventListener('click', () => {
                if (fuelLevel < maxFuelLevel) {
                    fuelLevel = maxFuelLevel; // Refuel instantly
                    updateFuelGauge();
                    displayMissionMessage("Fuel replenished! Press Main Power to resume flight.", 5000);
                    updateGasIconVisibility(); // Hide the icon after refueling
                } else {
                    displayMissionMessage("Fuel tanks are already full!", 3000);
                }
            });

            // New: Sound Icon click listener (mute/unmute)
            soundIcon.addEventListener('click', () => {
                if (isMuted) {
                    // Unmute: Restore previous volume
                    Tone.Destination.volume.value = Tone.Master.vol.linearToGain(lastVolume * 100); // Convert 0-1 to dB
                    // Ensure the continuous engine sound is playing if the game is flying
                    if (isFlying && Tone.context.state === 'running') {
                        startContinuousEngineSound();
                    }
                } else {
                    // Mute: Save current volume, set to -Infinity
                    lastVolume = volumeSlider.value / 100; // Save current slider value (0-1)
                    Tone.Destination.volume.value = -Infinity; // Mute
                    stopContinuousEngineSound(); // Stop the sound when muted
                }
                isMuted = !isMuted;
                updateSoundIcon();
                localStorage.setItem('gameSoundMuted', isMuted);
                localStorage.setItem('gameSoundVolume', lastVolume);
            });

            // New: Volume Slider input listener
            volumeSlider.addEventListener('input', () => {
                const sliderValue = parseInt(volumeSlider.value); // 0-100
                if (sliderValue === 0) {
                    Tone.Destination.volume.value = -Infinity; // Mute if slider is at 0
                    isMuted = true;
                    stopContinuousEngineSound();
                } else {
                    // Map slider value (0-100) to a dB range (e.g., -40dB to 0dB)
                    // Tone.js volume is logarithmic, so a linear mapping of slider to dB is fine.
                    // A slider value of 100 maps to 0dB (full volume)
                    // A slider value of 0 maps to -Infinity (mute), handled above.
                    // Let's use a range from -40dB (very quiet) to 0dB (max).
                    const minDb = -40; // Very quiet
                    const maxDb = 0;   // Max volume (no gain/loss)
                    const gain = ((sliderValue / 100) * (maxDb - minDb)) + minDb;
                    Tone.Destination.volume.value = gain;
                    isMuted = false;
                    // Ensure the continuous engine sound is playing if the game is flying and volume is above 0
                    if (isFlying && Tone.context.state === 'running' && sliderValue > 0) {
                        startContinuousEngineSound();
                    }
                }
                updateSoundIcon();
                localStorage.setItem('gameSoundMuted', isMuted);
                localStorage.setItem('gameSoundVolume', sliderValue / 100); // Save as 0-1 for consistency
            });


            // LLM Integration for Report Status / Request Data
            reportStatusButton.addEventListener('click', async () => {
                displayMissionMessage("Requesting status report...", 2000);
                loadingSpinner.style.display = 'block';
                console.log('Report Status button clicked. Initiating API call...');
                try {
                    // Ensure the LLM prompt uses the correct variable name
                    const prompt = `Generate a concise, retro-futuristic status report for a space mission game. Include current health (out of ${maxHealth}), fuel (${fuelLevel}/${maxFuelLevel}), and estimated distance from Earth (${distanceFromEarth.toLocaleString()} miles). Make it sound like a 1980s computer status message.`;
                    const payload = { contents: [{ role: "user", parts: [{ text: prompt }] }] };
                    const apiKey = "";
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    const result = await response.json();
                    console.log('Report Status API raw response:', result);
                    if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
                        const statusReport = result.candidates[0].content.parts[0].text;
                        console.log('Report Status parsed message:', statusReport);
                        displayMissionMessage(statusReport, 8000);
                        // No explicit statusReported flag needed for sequential dependency now,
                        // as user just wants to ensure messages come through.
                    } else {
                        displayMissionMessage("Error: No status report data received.", 3000);
                        console.error("LLM response structure unexpected for Report Status.");
                    }
                } catch (error) {
                    console.error("Error generating status report:", error);
                    displayMissionMessage("Error: Failed to connect to command center.", 3000);
                } finally {
                    loadingSpinner.style.display = 'none';
                }
            });

            requestDataButton.addEventListener('click', async () => {
                displayMissionMessage("Requesting planetary data...", 2000);
                loadingSpinner.style.display = 'block';
                console.log('Request Data button clicked. Initiating API call...');
                try {
                    const prompt = `As a retro 1980s mission control computer, generate a brief, cryptic message about an anomaly detected near a celestial body. Use terms like 'unknown energy signature', 'unidentified object', 'gravitational fluctuation'. Mention a specific, fictional planetary body like 'Zorgon Prime' or 'Nebula X'. Keep it short and impactful.`;
                    const payload = { contents: [{ role: "user", parts: [{ text: prompt }] }] };
                    const apiKey = "";
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    const result = await response.json();
                    console.log('Request Data API raw response:', result);
                    if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
                        const dataReport = result.candidates[0].content.parts[0].text;
                        console.log('Request Data parsed message:', dataReport);
                        displayMissionMessage(dataReport, 8000);
                    } else {
                        displayMissionMessage("Error: No data received from deep space probe.", 3000);
                        console.error("LLM response structure unexpected for Request Data.");
                    }
                } catch (error) {
                    console.error("Error requesting data:", error);
                    displayMissionMessage("Error: Communications scrambled.", 3000);
                } finally {
                    loadingSpinner.style.display = 'none';
                }
            });


            // Joystick/Keyboard Movement Controls
            const keysPressed = {};

            document.addEventListener('keydown', (event) => {
                keysPressed[event.key.toLowerCase()] = true;
                updateMoveState();
            });

            document.addEventListener('keyup', (event) => {
                delete keysPressed[event.key.toLowerCase()];
                updateMoveState();
            });

            function updateMoveState() {
                moveX = 0;
                moveY = 0;
                if (keysPressed['arrowleft'] || keysPressed['a']) moveX = -1;
                if (keysPressed['arrowright'] || keysPressed['d']) moveX = 1;
                if (keysPressed['arrowup'] || keysPressed['w']) moveY = 1;
                if (keysPressed['arrowdown'] || keysPressed['s']) moveY = -1;
            }

            // Touch/Click listeners for joystick buttons
            const setupButtonMovement = (buttonId, xDir, yDir) => {
                const button = document.getElementById(buttonId);
                if (button) {
                    const startMove = () => {
                        if (isFlying) {
                            moveX = xDir;
                            moveY = yDir;
                        }
                    };
                    const stopMove = () => {
                        if (isFlying) {
                            if (moveX === xDir) moveX = 0;
                            if (moveY === yDir) moveY = 0;
                        }
                    };

                    button.addEventListener('mousedown', startMove);
                    button.addEventListener('mouseup', stopMove);
                    button.addEventListener('mouseleave', stopMove);

                    button.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        startMove();
                    }, { passive: false });
                    button.addEventListener('touchend', stopMove);
                    button.addEventListener('touchcancel', stopMove);
                }
            };

            setupButtonMovement('move-left', -1, 0);
            setupButtonMovement('move-right', 1, 0);
            setupButtonMovement('move-up', 0, 1);
            setupButtonMovement('move-down', 0, -1);
        }

        /**
         * Loads saved sound preferences from local storage.
         */
        function loadSoundPreferences() {
            const savedMuteState = localStorage.getItem('gameSoundMuted');
            const savedVolume = localStorage.getItem('gameSoundVolume');

            if (savedMuteState !== null) {
                isMuted = JSON.parse(savedMuteState);
            }
            if (savedVolume !== null) {
                lastVolume = parseFloat(savedVolume);
                volumeSlider.value = lastVolume * 100; // Set slider value (0-100)
            } else {
                volumeSlider.value = lastVolume * 100; // Default to 70 if no saved volume
            }

            // Apply loaded preferences
            if (isMuted) {
                Tone.Destination.volume.value = -Infinity; // Mute
            } else {
                const minDb = -40; // Very quiet
                const maxDb = 0;   // Max volume (no gain/loss)
                const gain = (lastVolume * (maxDb - minDb)) + minDb;
                Tone.Destination.volume.value = gain;
            }
            updateSoundIcon();
        }

        /**
         * Resets the Three.js scene elements to their initial game state.
         * This is called by startGame() to prepare for a new game session.
         */
        function resetGameScene() {
            // Remove all existing planets and asteroids from the scene
            planets.forEach(p => scene.remove(p));
            planets = [];
            asteroids.forEach(a => scene.remove(a));
            asteroids = [];
            otherSpacecrafts.forEach(s => scene.remove(s));
            otherSpacecrafts = [];

            // Reset spacecraft position and make it visible
            if (bluOrbitSpaceship) {
                bluOrbitSpaceship.position.set(0, 0, 0);
                bluOrbitSpaceship.rotation.set(0, 0, 0);
                bluOrbitSpaceship.visible = true; // Ensure it's visible
            }
            // Reset fire particles opacity
            if (frontEngineFireParticles) {
                frontEngineFireParticles.material.opacity = 0.8;
            }

            // Reset ground position and make it visible
            if (ground) {
                ground.position.set(0, -2.5, 0);
                ground.visible = true;
            }

            // Re-spawn initial planets and asteroids for the new game
            for (let i = 0; i < 10; i++) {
                createPlanetObject();
            }
            for (let i = 0; i < 10; i++) { // Add initial asteroids
                createAsteroidObject();
            }

            // Reset spawn rates to initial values
            planetSpawnRate = 1000;
            lastPlanetSpawnTime = performance.now();
            asteroidSpawnRate = 200;
            lastAsteroidSpawnTime = performance.now();
            lastPlanetBatchTime = performance.now(); // Reset batch time
            otherSpacecraftSpawnRate = 30000;
            lastOtherSpacecraftSpawnTime = performance.now();

            // Reset deep space tier
            currentDeepSpaceTier = 1;
            updateDeepSpaceBackground(currentDeepSpaceTier); // Apply initial background
            updateDeepSpaceFog(currentDeepSpaceTier); // Clear fog
        }


        /**
         * Starts a new game session. Resets all game state (except global distance).
         */
        async function startGame() {
            console.log("startGame initiated.");
            document.getElementById('loading-spinner').style.display = 'block';

            // Ensure Firebase is ready and fetch initial global distance
            distanceFromEarth = await fetchInitialGlobalDistance();
            console.log("Game starting with global distance:", distanceFromEarth);

            // Reset the Three.js scene elements for a new game
            resetGameScene();

            document.getElementById('loading-spinner').style.display = 'none';

            // Hide startup screen
            startupScreen.style.display = 'none';

            // Show all game UI elements after initialization
            gameTitleContainer.classList.remove('hidden');
            fuelGaugeContainer.classList.remove('hidden');
            miniMapContainer.classList.remove('hidden');
            missionMessageArea.classList.remove('hidden');
            healthBarContainerElement.classList.remove('hidden');
            controlPanelContainer.classList.remove('hidden');
            joystickControls.classList.remove('hidden');
            soundControlContainer.classList.remove('hidden'); // Show sound control

            // Reset game state for local player
            spacecraftHealth = maxHealth;
            fuelLevel = maxFuelLevel;
            currentFlightSpeed = baseFlightSpeed;
            isFlying = true;
            console.log(`startGame: isFlying=${isFlying}, currentFlightSpeed=${currentFlightSpeed}`);

            // Reset UI
            updateHealthBar();
            updateFuelGauge();
            updateGasIconVisibility(); // Ensure gas icon is hidden on game start
            displayMissionMessage("Engines ignited! Flight initiated into interstellar space. Global voyage in progress.", 3000);
            mainPowerButton.textContent = "Power: ON"; // Changed for clarity
            thrustControlButton.textContent = "Thrust: ON"; // Changed for clarity
            engineIgniteButton.textContent = "Ignite Engines"; // Ensure ignite button text is correct

            // Start continuous engine sound only if not muted and game is flying
            if (!isMuted && Tone.context.state === 'running') {
                startContinuousEngineSound();
            }

            // Start the persistent distance updater
            startGlobalDistanceUpdater();

            // Ensure the animation loop is running (it might have been cancelled on game over)
            if (!requestAnimationFrameId) {
                console.log("startGame: Re-starting animation loop.");
                animate();
            }
        }

        let requestAnimationFrameId;

        /**
         * Creates a particle system for engine fire.
         * @param {boolean} isFrontFire - True if creating fire for the front of the ship (particles move negatively in Z).
         * @returns {{particles: THREE.Points, particleData: Array}} An object containing the particle system and its data.
         */
        function createEngineFireParticleSystem(isFrontFire = false) {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(fireParticleCount * 3);
            const colors = new Float32Array(fireParticleCount * 3);
            const particleData = [];

            const color1 = new THREE.Color(0xffa500); // Orange
            const color2 = new THREE.Color(0xff4500); // Orange-Red
            const color3 = new THREE.Color(0xff0000); // Red

            const zVelocitySign = isFrontFire ? -1 : 1; // Negative for front (moves towards -Z), Positive for rear (moves towards +Z)

            for (let i = 0; i < fireParticleCount; i++) {
                const i3 = i * 3;
                positions[i3] = (Math.random() - 0.5) * 1.5; // X spread
                positions[i3 + 1] = (Math.random() - 0.5) * 1.5; // Y spread
                positions[i3 + 2] = (isFrontFire ? 1 : -1) * Math.random() * 2; // Initial Z position relative to emission point

                const color = new THREE.Color();
                color.lerpColors(color1, color2, Math.random());
                color.lerpColors(color, color3, Math.random());
                colors[i3] = color.r;
                colors[i3+1] = color.g;
                colors[i3+2] = color.b;

                particleData[i] = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.05,
                        (Math.random() - 0.5) * 0.05,
                        zVelocitySign * (Math.random() * 0.3 + 0.1) // Particles move away from ship
                    )
                };
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 1.0, // Increased size of each particle
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });

            const particles = new THREE.Points(geometry, material);
            return { particles, particleData };
        }

        /**
         * Updates fire particle positions and properties for animation.
         * @param {THREE.Points} particles The particle system to update.
         * @param {Array} particlesData The data array for particles.
         * @param {number} referenceZ The Z position of the ship's end where fire is emitted in its local coordinates.
         * @param {boolean} isFrontFire - True if this is fire from the front of the ship.
         */
        function updateFireParticles(particles, particlesData, referenceZ, isFrontFire = false) {
            if (!particles || !particles.geometry || !particles.geometry.attributes || !particles.geometry.attributes.position) {
                return;
            }

            const positions = particles.geometry.attributes.position.array;
            const colors = particles.geometry.attributes.color.array;

            const color1 = new THREE.Color(0xffa500);
            const color2 = new THREE.Color(0xff4500);
            const color3 = new THREE.Color(0xff0000);

            const zResetDirection = isFrontFire ? 1 : -1; // Reset particles to be in front of emitter for front fire, behind for rear
            const zVelocitySign = isFrontFire ? -1 : 1; // Velocity direction

            for (let i = 0; i < fireParticleCount; i++) {
                const i3 = i * 3;
                const particleDataEntry = particlesData[i];

                positions[i3] += particleDataEntry.velocity.x;
                positions[i3 + 1] += particleDataEntry.velocity.y;
                positions[i3 + 2] += particleDataEntry.velocity.z;

                // Reset particle if it moves too far from the origin
                // For front fire: if particle Z is less than (referenceZ - some_distance)
                // For rear fire: if particle Z is greater than (referenceZ + some_distance)
                const distanceThreshold = 2; // Distance particles travel before reset

                let shouldReset = false;
                if (isFrontFire) {
                    if (positions[i3 + 2] < (referenceZ - distanceThreshold)) {
                        shouldReset = true;
                    }
                } else { // Rear fire
                    if (positions[i3 + 2] > (referenceZ + distanceThreshold)) {
                        shouldReset = true;
                    }
                }

                if (shouldReset || Math.abs(positions[i3]) > 2 || Math.abs(positions[i3+1]) > 2) { // Also reset if too far laterally
                    positions[i3] = (Math.random() - 0.5) * 1.5;
                    positions[i3 + 1] = (Math.random() - 0.5) * 1.5;
                    positions[i3 + 2] = referenceZ + (zResetDirection * Math.random() * 2); // Reset to just behind/in front of emitter
                    particleDataEntry.velocity.set(
                        (Math.random() - 0.5) * 0.05,
                        (Math.random() - 0.5) * 0.05,
                        zVelocitySign * (Math.random() * 0.3 + 0.1)
                    );
                    const color = new THREE.Color();
                    color.lerpColors(color1, color2, Math.random());
                    color.lerpColors(color, color3, Math.random());
                    colors[i3] = color.r;
                    colors[i3+1] = color.g;
                    colors[i3+2] = color.b;
                }
            }
            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.attributes.color.needsUpdate = true;
        }


        // Function to create a stylized planet (for non-collectible celestial bodies)
        function createPlanet(radius, colorHex, type = 'rocky') {
            let planetMaterial;
            // Use different material types based on type for visual variety
            if (type === 'rocky') {
                planetMaterial = new THREE.MeshStandardMaterial({
                    color: colorHex,
                    metalness: 0.3,
                    roughness: 0.7,
                    flatShading: false
                });
            } else if (type === 'gas') {
                planetMaterial = new THREE.MeshPhongMaterial({
                    color: colorHex,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending,
                    emissive: colorHex,
                    emissiveIntensity: 0.15,
                    shininess: 50
                });
            } else if (type === 'ice') {
                planetMaterial = new THREE.MeshStandardMaterial({
                    color: colorHex,
                    metalness: 0.7,
                    roughness: 0.2,
                    flatShading: false
                });
            }

            const planetGeometry = new THREE.SphereGeometry(radius, 64, 64);
            const planet = new THREE.Mesh(planetGeometry, planetMaterial);
            planet.radius = radius;
            if (type === 'gas') {
                const ringGeometry = new THREE.TorusGeometry(planet.radius * 1.2, planet.radius * 0.1, 2, 100);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0x8888aa,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.6
                });
                const rings = new THREE.Mesh(ringGeometry, ringMaterial);
                rings.rotation.x = Math.PI / 2;
                planet.add(rings);
            }
            return planet;
        }

        // Function to set up the main spaceship model (now always a primitive)
        async function setupSpacecraftModel() {
            // Only create if it doesn't exist. If it exists, it will be reset by resetGameScene.
            if (!bluOrbitSpaceship) {
                console.warn('Creating default primitive spaceship model.');
                const playerGeometry = new THREE.BoxGeometry(3, 3, 8); // Increased size for visibility (width, height, depth)
                const playerMaterial = new THREE.MeshPhongMaterial({ color: 0x00ffff, flatShading: true }); // Cyan color
                bluOrbitSpaceship = new THREE.Mesh(playerGeometry, playerMaterial);
                bluOrbitSpaceship.position.set(0, 0, 0); // Ship is at origin
                bluOrbitSpaceship.rotation.y = 0; // Explicitly no Y rotation
                bluOrbitSpaceship.radius = 4; // Half of its length (8 units) for collision
                scene.add(bluOrbitSpaceship); // Add to scene only once initially

                // Create front engine fire particle system and attach to ship
                const { particles: fireParticles, particleData: fireData } = createEngineFireParticleSystem(true); // True for front fire
                frontEngineFireParticles = fireParticles;
                frontFireParticlesData = fireData;
                frontEngineFireParticles.position.set(0, 0, 4); // Position fire at the local +Z (front of the box)
                bluOrbitSpaceship.add(frontEngineFireParticles);
                displayMissionMessage("Loaded primitive craft with front-facing particle effects.", 3000);
            } else {
                 console.log('Spacecraft model already exists, skipping recreation.');
            }
        }


        async function initThreeJS() {
            scene = new THREE.Scene();
            // Initial skybox color (can be dynamically updated)
            scene.background = new THREE.Color(0x02020a);

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 15); // Camera in front and slightly above the ship
            camera.lookAt(0, 0, 0); // Look at the ship (at origin)
            console.log('Initial Main Camera position:', camera.position);
            console.log('Initial Main Camera rotation (lookAt implied):', camera.rotation);


            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            const threeContainer = document.getElementById('three-container');
            if (threeContainer && threeContainer.children.length === 0) {
                threeContainer.appendChild(renderer.domElement);
            }
            renderer.autoClear = true; // Only one scene now, can clear automatically

            // Lighting for Main Scene
            const ambientLight = new THREE.AmbientLight(0x303030, 1);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight.position.set(10, 5, -15).normalize();
            scene.add(directionalLight);
            const pointLight = new THREE.PointLight(0x00f0ff, 0.3, 50, 2);
            pointLight.position.set(0, 1, -2); // Position relative to world
            scene.add(pointLight);


            // Set up the main spaceship model (only creates if it doesn't exist)
            await setupSpacecraftModel();


            // Deep Space Background (Skybox, stars, nebulas)
            skybox = new THREE.Mesh(
                new THREE.SphereGeometry(700, 64, 64),
                new THREE.MeshBasicMaterial({ color: 0x010105, side: THREE.BackSide })
            );
            scene.add(skybox);

            const starColors = [0xffffff, 0xaaaaff, 0xffffaa, 0xffaaff];
            for (let i = 0; i < 1500; i++) {
                const starRadius = Math.random() * 0.08 + 0.03;
                const starGeometry = new THREE.SphereGeometry(starRadius, 8, 8);
                const starMaterial = new THREE.MeshBasicMaterial({ color: starColors[Math.floor(Math.random() * starColors.length)] });
                const star = new THREE.Mesh(starGeometry, starMaterial);
                const r = 300 + Math.random() * 400; const theta = Math.random() * Math.PI * 2; const phi = Math.acos(Math.random() * 2 - 1);
                star.position.set(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
                skybox.add(star);
            }

            const nebulaColors = [0x5500aa, 0x0055ff, 0xaa00aa, 0xff00ff, 0x00ffff];
            for (let i = 0; i < 10; i++) {
                const nebulaSize = 50 + Math.random() * 100;
                const nebulaMaterial = new THREE.MeshBasicMaterial({
                    color: nebulaColors[Math.floor(Math.random() * nebulaColors.length)], transparent: true, opacity: 0.2 + Math.random() * 0.15,
                    blending: THREE.AdditiveBlending, side: THREE.FrontSide
                });
                const nebula = new THREE.Mesh(new THREE.SphereGeometry(nebulaSize, 16, 16), nebulaMaterial);
                nebula.position.set((Math.random() - 0.5) * 800, (Math.random() - 0.5) * 800, -300 - Math.random() * 500);
                skybox.add(nebula);
            }

            // Ground/Launch Pad (initially visible, moves away)
            ground = new THREE.Mesh(
                new THREE.PlaneGeometry(50, 50),
                new THREE.MeshStandardMaterial({ color: 0x444444, side: THREE.DoubleSide })
            );
            ground.rotation.x = THREE.MathUtils.degToRad(-90);
            ground.position.y = -2.5;
            ground.visible = true;
            scene.add(ground);

            // Initialize fog (default none/black)
            scene.fog = null; // No fog initially

            // Mouse control for camera rotation (rotates the camera around the ship)
            let isMouseDown = false;
            let previousMouseX = 0;
            let previousMouseY = 0;

            document.addEventListener('mousedown', (event) => {
                if (event.target.tagName === 'CANVAS') {
                    isMouseDown = true;
                    previousMouseX = event.clientX;
                    previousMouseY = event.clientY;
                }
            });

            document.addEventListener('mouseup', () => {
                isMouseDown = false;
            });

            document.addEventListener('mousemove', (event) => {
                if (!isMouseDown) return;

                const deltaX = event.clientX - previousMouseX;
                const deltaY = event.clientY - previousMouseY;

                // Rotate camera around the spaceship (at origin 0,0,0)
                // This makes the spaceship appear to rotate in the view
                const cameraTarget = new THREE.Vector3(0,0,0);
                const currentCameraPosition = camera.position.clone();
                camera.position.sub(cameraTarget); // Translate to origin
                camera.position.applyAxisAngle(new THREE.Vector3(0,1,0), -deltaX * 0.005); // Rotate around Y axis
                camera.position.applyAxisAngle(new THREE.Vector3(1,0,0), -deltaY * 0.005); // Rotate around X axis
                camera.position.add(cameraTarget); // Translate back
                camera.lookAt(cameraTarget); // Always look at the spaceship

                previousMouseX = event.clientX;
                previousMouseY = event.clientY;
            });

            // Touch control for camera rotation
            let isTouchingCamera = false;
            let touchStartX = 0;
            let touchStartY = 0;

            document.addEventListener('touchstart', (event) => {
                // Check if the touch is not on any joystick button before enabling camera touch
                // This prevents conflicts between player movement and camera movement
                const targetId = event.target.id;
                if (!targetId.startsWith('move-') && targetId !== 'main-power-button' &&
                    targetId !== 'engine-ignite-button' && targetId !== 'thrust-control-button' &&
                    targetId !== 'report-status-button' && targetId !== 'request-data-button' &&
                    targetId !== 'gas-icon-container' && targetId !== 'sound-control-container' &&
                    targetId !== 'volume-slider' && targetId !== 'sound-icon' &&
                    event.target.tagName !== 'BUTTON' && event.target.tagName !== 'INPUT' &&
                    event.target.tagName !== 'A') { // Exclude UI elements from camera touch
                    
                    isTouchingCamera = true;
                    touchStartX = event.touches[0].clientX;
                    touchStartY = event.touches[0].clientY;
                }
            }, { passive: true }); // Use passive: true as this touch doesn't prevent scrolling

            document.addEventListener('touchend', () => {
                isTouchingCamera = false;
            }, { passive: true });

            document.addEventListener('touchmove', (event) => {
                if (!isTouchingCamera) return;
                if (event.touches.length === 0) return; // No active touches

                const currentX = event.touches[0].clientX;
                const currentY = event.touches[0].clientY;

                const deltaX = currentX - touchStartX;
                const deltaY = currentY - touchStartY;

                // Rotate camera around the spaceship (at origin 0,0,0)
                const cameraTarget = new THREE.Vector3(0,0,0);
                camera.position.sub(cameraTarget); // Translate to origin
                camera.position.applyAxisAngle(new THREE.Vector3(0,1,0), -deltaX * 0.005); // Rotate around Y axis
                camera.position.applyAxisAngle(new THREE.Vector3(1,0,0), -deltaY * 0.005); // Rotate around X axis
                camera.position.add(cameraTarget); // Translate back
                camera.lookAt(cameraTarget); // Always look at the spaceship

                touchStartX = currentX;
                touchStartY = currentY;
            }, { passive: true });


            // Keyboard controls (move the spaceship)
            document.addEventListener('keydown', (event) => {
                if (!isFlying) return;
                switch (event.key.toLowerCase()) {
                    case 'arrowleft': moveX = -1; break;
                    case 'a': moveX = -1; break;
                    case 'arrowright': moveX = 1; break;
                    case 'd': moveX = 1; break;
                    case 'arrowup': moveY = 1; break;
                    case 'w': moveY = 1; break;
                    case 'arrowdown': moveY = -1; break;
                    case 's': moveY = -1; break;
                }
            });

            document.addEventListener('keyup', (event) => {
                if (!isFlying) return;
                switch (event.key.toLowerCase()) {
                    case 'arrowleft': if (moveX === -1) moveX = 0; break;
                    case 'a': if (moveX === -1) moveX = 0; break;
                    case 'arrowright': if (moveX === 1) moveX = 0; break;
                    case 'd': if (moveX === 1) moveX = 0; break;
                    case 'arrowup': if (moveY === 1) moveY = 0; break;
                    case 'w': if (moveY === 1) moveY = 0; break;
                    case 'arrowdown': if (moveY === -1) moveY = 0; break;
                    case 's': if (moveY === -1) moveY = 0; break;
                }
            });

            // Handle window resizing
            window.addEventListener('resize', onWindowResize, false);
        }


        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        /**
         * Handles collision effects and game state updates.
         * @param {THREE.Object3D} collidedObject The object that was collided with.
         * @param {string} type The type of object collided with ("planet" or "asteroid").
         */
        function handleCollision(collidedObject, type) {
            if (!isFlying) return;

            let damage = 0;
            let message = "";
            if (type === "planet") {
                damage = 2; // More severe damage from planets
                message = `CRITICAL IMPACT! Direct hit by large celestial body! Health at ${spacecraftHealth}/${maxHealth}.`;
            } else if (type === "asteroid") {
                damage = 1; // Less severe damage from asteroids
                message = `IMPACT! Asteroid strike! Hull integrity compromised. Health at ${spacecraftHealth}/${maxHealth}.`;
            }

            spacecraftHealth -= damage;
            updateHealthBar();
            displayMissionMessage(message, 3000);

            // Play explosion sound (Tone.js)
            const explosionSynth = new Tone.NoiseSynth({
                noise: { type: "pink" },
                envelope: { attack: 0.001, decay: 0.2, sustain: 0, release: 0.5 },
                volume: -5
            }).toDestination();
            explosionSynth.triggerAttackRelease("1n");

            // Remove the collided object from the scene and its respective array
            if (collidedObject.parent) {
                scene.remove(collidedObject);
                if (type === "planet") {
                    planets = planets.filter(p => p !== collidedObject);
                }
                else if (type === "asteroid") {
                    asteroids = asteroids.filter(a => a !== collidedObject);
                }
            }

            if (spacecraftHealth <= 0) {
                displayMissionMessage("CRITICAL FAILURE! Emergency reset initiated. System Rebooting...", 5000);
                isFlying = false;
                currentFlightSpeed = 0;
                moveX = 0;
                moveY = 0;

                if (frontEngineFireParticles) { frontEngineFireParticles.material.opacity = 0.0; }
                stopContinuousEngineSound(); // Stop engine sound on critical failure

                setTimeout(() => {
                    gameOver();
                }, 4000);
                return;
            }

            // Minor position nudge back on impact
            // This now applies to the spaceship's position in the world
            bluOrbitSpaceship.position.z += 5;
        }

        // Initialize game and Firebase on window load
        window.onload = async function () {
            setupUIEventListeners();
            updateHealthBar();
            updateFuelGauge();
            loadSoundPreferences(); // Load sound preferences on startup

            // Initialize Firebase as soon as window loads, but don't start game yet
            await initFirebase(); // Wait for Firebase to be ready before proceeding

            // Initialize Three.js scene once here
            await initThreeJS();
            // Start the animation loop once here
            animate();

            // Show the startup screen initially
            startupScreen.style.display = 'flex';
        };
    </script>
</body>
</html>
