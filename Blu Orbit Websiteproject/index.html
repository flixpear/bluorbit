<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dolumbican Blu Orbit - Takeoff Pad</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts for retro title -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* Custom styles for a retro, space-age feel */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117; /* Dark space background */
            color: #e0e0e0;
            overflow: hidden; /* Prevent scrolling */
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end; /* Align items to the bottom */
            min-height: 100vh;
        }
        canvas {
            display: block;
            background-color: transparent; /* Three.js will render against the body background */
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1; /* Below UI */
        }

        /* Main UI container for health bar and control panel - centered at bottom */
        #ui-container {
            position: absolute;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10; /* Above canvas */
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 90%;
            max-width: 1000px;
            padding-bottom: 0.5rem;
            pointer-events: none; /* Allows mouse events to pass through to canvas for camera control */
            min-height: 120px; /* Ensure space for content */
        }

        /* Main Game Title - positioned at the very top center */
        #game-title-container {
            position: absolute;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 1000px;
            z-index: 10;
            pointer-events: none; /* Only title, no interaction */
            text-align: center;
        }
        #game-title-container h1 {
            pointer-events: auto; /* Make title text itself selectable/interactable */
        }


        /* Mission Control Message Area - positioned bottom-left */
        #mission-message-area {
            position: absolute;
            bottom: 8.5rem; /* Adjust as needed to be above the control panel */
            left: 1rem;
            z-index: 10;
            pointer-events: auto; /* Allow interactions within message box */
            max-width: 300px; /* Constrain width */
            padding: 0.5rem; /* Padding around the message box */
        }

        #message-box {
            background-color: rgba(30, 40, 50, 0.9);
            color: #00f0ff; /* Neon blue text */
            border: 2px solid #00f0ff;
            border-radius: 0.75rem;
            padding: 0.7rem;
            text-align: left; /* Align text left */
            font-size: 0.9rem;
            font-weight: bold;
            box-shadow: 0 0 8px rgba(0, 240, 255, 0.3);
            min-height: 35px;
            display: flex;
            align-items: center;
            justify-content: flex-start; /* Align content to the start (left) */
            width: 100%; /* Take full width of its parent */
        }

        #health-bar-container {
            pointer-events: auto;
            width: 100%;
            max-width: 200px;
            display: flex;
            justify-content: center;
            margin-bottom: 1rem; /* Space between health bar and control panel */
        }
        .health-notch {
            width: 30px;
            height: 15px;
            background-color: #00ff00; /* Green for full health */
            border: 1px solid #00bb00;
            margin: 0 2px;
            border-radius: 3px;
            box-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
        }
        .health-notch.damaged {
            background-color: #ffcc00; /* Yellow for damaged */
            box-shadow: 0 0 5px rgba(255, 204, 0, 0.5);
        }
        .health-notch.critical {
            background-color: #ff0000; /* Red for critical */
            box-shadow: 0 0 5px rgba(255, 0, 0, 0.7);
        }

        /* Fuel Gauge Container */
        #fuel-gauge-container {
            position: absolute;
            top: 1rem; /* Aligned with game title, but on the left now */
            left: 1rem;
            z-index: 10;
            pointer-events: auto;
            width: 100px; /* Fixed width */
            height: 100px; /* Adjusted height for circle */
            background-color: rgba(30, 40, 50, 0.7);
            border: 2px solid #00f0ff;
            border-radius: 50%; /* Make it circular */
            box-shadow: 0 0 8px rgba(0, 240, 255, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 5px;
            box-sizing: border-box;
        }

        #fuel-gauge-container svg {
            width: 90%; /* Adjust SVG size within container */
            height: 90%;
            filter: drop-shadow(0 0 2px rgba(0, 240, 255, 0.5)); /* Subtle glow for the gauge */
        }

        #fuel-needle-line { /* Changed to #fuel-needle-line */
            transform-origin: 50px 50px; /* Center of the SVG viewBox */
            transition: transform 0.3s ease-out, stroke 0.3s ease-out; /* Smooth transition for needle movement and color */
        }

        #fuel-label {
            font-size: 8px; /* Smaller font for circular gauge label */
            font-weight: bold;
            fill: #00f0ff; /* Neon blue for label */
            pointer-events: none; /* Don't block interactions if any */
        }

        #fuel-pump-icon {
            fill: #00f0ff; /* Neon blue for the icon */
        }

        /* Mini-Map Container */
        #mini-map-container {
            position: absolute;
            top: 120px; /* Below fuel gauge */
            left: 1rem;
            z-index: 10;
            pointer-events: auto;
            width: 100px;
            height: 100px;
            background-color: rgba(30, 40, 50, 0.7);
            border: 2px solid #00f0ff;
            border-radius: 50%;
            box-shadow: 0 0 8px rgba(0, 240, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #mini-map-container svg {
            width: 90px;
            height: 90px;
        }
        #mini-map-label {
            font-size: 8px;
            font-weight: bold;
            fill: #00f0ff;
            pointer-events: none;
        }
        .map-dot {
            transition: transform 0.1s linear; /* Smooth movement for dots */
        }
        /* Pulsating effect for extra-terrestrial activity dot */
        .map-dot.pulsating {
            animation: pulse-dot 1s infinite alternate;
        }
        @keyframes pulse-dot {
            from { r: 3px; }
            to { r: 5px; }
        }


        #control-panel-container {
            pointer-events: auto; /* Re-enable pointer events for UI elements */
            width: 100%;
            display: flex;
            justify-content: center; /* Center the entire control panel block */
            margin-top: 0.5rem; /* Space between health bar and panel */
        }

        #control-panel {
            display: flex; /* Changed to flex for horizontal layout */
            flex-wrap: wrap; /* Allow buttons to wrap to next line on smaller screens */
            justify-content: center; /* Center buttons within the flex container */
            align-items: center; /* Align items vertically in the center */
            width: auto; /* Allow width to be determined by content */
            max-width: 95%; /* Constrain max width for large screens */
            padding: 0.5rem; /* Reduced padding for more compact layout */
            position: relative; /* For absolute positioning of buttons relative to this */
        }
        .retro-button {
            background-color: rgba(0, 150, 0, 0.8); /* Darker green base */
            color: #00ff00; /* Neon green text */
            padding: 0.6rem 0.8rem; /* Even smaller padding for smaller buttons */
            border-radius: 0.4rem; /* Slightly smaller radius */
            border: 2px solid #00ff00; /* Neon green border */
            cursor: pointer;
            font-size: 0.7rem; /* Smaller font size */
            font-weight: bold;
            text-transform: uppercase;
            box-shadow: inset 0 0 4px rgba(0, 255, 0, 0.3), 0 0 10px rgba(0, 255, 0, 0.5); /* Neon green glow shadow */
            transition: all 0.15s ease-in-out;
            position: relative;
            overflow: hidden;
            letter-spacing: 0.05em; /* Add some spacing for retro feel */
            margin: 0.3rem; /* Consistent margin for flex items */
        }
        .retro-button:hover {
            background-color: rgba(0, 200, 0, 0.9); /* Brighter green on hover */
            box-shadow: inset 0 0 6px rgba(0, 255, 0, 0.5), 0 0 15px rgba(0, 255, 0, 0.7);
            transform: translateY(-1px);
        }
        .retro-button:active {
            background-color: rgba(0, 100, 0, 0.9); /* Even darker green on active */
            box-shadow: inset 0 0 2px rgba(0, 255, 0, 0.2), 0 0 5px rgba(0, 255, 0, 0.3);
            transform: translateY(0);
        }
        .retro-button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            opacity: 0;
            transition: width 0.2s ease, height 0.2s ease, opacity 0.2s ease;
        }
        .retro-button:active::before {
            width: 150%;
            height: 150%;
            opacity: 1;
        }
        #pip-container {
            position: absolute;
            top: 2rem; /* Moved to top */
            right: 2rem; /* Moved to right */
            width: 180px; /* Fixed width for PiP */
            height: 120px; /* Fixed height for PiP */
            background-color: rgba(0, 0, 0, 0.7);
            border: 2px solid #00f0ff;
            border-radius: 0.75rem;
            overflow: hidden; /* Hide anything outside the PiP view */
            z-index: 15; /* Ensure it's above everything else */
            box-shadow: 0 0 15px rgba(0, 240, 255, 0.5);
            pointer-events: none; /* Do not interfere with main canvas mouse events */
        }
        #pip-container::before {
            content: 'BACK VIEW'; /* Updated to reflect back view */
            position: absolute;
            top: 5px;
            left: 5px;
            color: #00f0ff;
            font-size: 0.7rem;
            font-weight: bold;
            z-index: 20; /* Above the internal canvas */
        }

        /* Joystick controls styling */
        #joystick-controls {
            pointer-events: auto; /* Re-enable pointer events for UI elements */
            position: absolute;
            bottom: 7rem; /* Aligned with PiP container */
            width: 100%;
            display: flex;
            justify-content: space-between; /* Space out left and right joysticks */
            padding: 0 2rem; /* Padding from edges */
            box-sizing: border-box;
        }

        .joystick-module {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .directional-button {
            background-color: #006060; /* Darker teal */
            color: #e0e0e0;
            width: 50px;
            height: 50px;
            border-radius: 50%; /* Circular buttons */
            border: 2px solid #00f0ff; /* Neon border */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem; /* Larger arrow icons */
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 240, 255, 0.3);
            transition: all 0.1s ease-in-out;
            margin: 0.2rem; /* Small margin between buttons */
        }

        .directional-button:hover {
            background-color: #008080;
            box-shadow: 0 0 15px rgba(0, 240, 255, 0.5);
        }

        .directional-button:active {
            background-color: #004040;
            transform: scale(0.95);
        }

        .joystick-group-vertical {
            display: flex;
            flex-direction: column;
        }

        .joystick-group-horizontal {
            display: flex;
        }

        /* Adjust positioning for joystick elements */
        #joystick-left {
            align-self: flex-end; /* Pushes left group to bottom-left of its container */
        }

        #joystick-right {
            align-self: flex-end; /* Pushes right group to bottom-right of its container */
        }

        /* Loading Spinner */
        #loading-spinner {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 4px solid rgba(0, 240, 255, 0.3);
            border-top: 4px solid #00f0ff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            z-index: 100; /* Ensure it's on top */
            display: none; /* Hidden by default */
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Startup Screen Styles */
        #startup-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #0d1117; /* Same as body background */
            z-index: 20; /* Above everything else */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            opacity: 1;
            transition: opacity 0.5s ease-out;
        }
        #startup-screen.hidden {
            opacity: 0;
            pointer-events: none; /* Prevent interaction when hidden */
        }
        #startup-screen .game-title-1989 {
            font-family: 'Press Start 2P', cursive; /* Apply retro font */
            font-size: 2.8rem; /* Slightly larger */
            color: #00f0ff; /* Neon blue */
            margin-bottom: 2rem;
            text-shadow: 0 0 5px #00f0ff, /* Subtle glow */
                         0 0 15px #00f0ff,
                         0 0 30px #00f0ff,
                         0 0 45px #00f0ff; /* Stronger glow */
            letter-spacing: 0.15em; /* Space out letters for retro feel */
            white-space: nowrap; /* Prevent title from wrapping */
        }
        #startup-screen .startup-button-group {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            margin-bottom: 2rem; /* Space before copyright */
        }
        #startup-screen .startup-button {
            padding: 1.5rem 3rem;
            font-size: 1.5rem;
            border-radius: 1rem;
            border: 3px solid #00ff00;
            background-color: rgba(0, 150, 0, 0.7);
            color: #00ff00;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
            text-transform: uppercase;
            font-weight: bold;
        }
        #startup-screen .startup-button:hover {
            background-color: rgba(0, 200, 0, 0.9);
            box-shadow: 0 0 25px rgba(0, 255, 0, 0.9);
            transform: scale(1.05);
        }
        #startup-screen .startup-button:active {
            background-color: rgba(0, 100, 0, 0.9);
            transform: scale(0.98);
        }
        #startup-screen .copyright-text {
            font-family: 'Inter', sans-serif; /* Keep Inter for readability */
            font-size: 0.8rem;
            color: #aaa;
            text-shadow: 0 0 5px rgba(170, 170, 170, 0.3);
        }


        /* Responsive adjustments */
        @media (max-width: 768px) {
            #control-panel {
                gap: 0.3rem; /* Even smaller gap on mobile */
                padding: 0.3rem;
            }
            .retro-button {
                padding: 0.4rem 0.6rem;
                font-size: 0.55rem;
                margin: 0.2rem;
            }
            #message-box {
                font-size: 0.7rem;
                padding: 0.4rem;
                width: 90%;
            }
            #game-title-container {
                top: 0.5rem; /* Adjust for mobile */
            }
            #mission-message-area {
                bottom: 7.5rem; /* Adjust for mobile */
                left: 0.5rem;
                max-width: 250px;
            }
            #fuel-gauge-container {
                width: 80px; /* Smaller fuel gauge on mobile */
                height: 80px; /* Keep it square for circle border-radius */
                top: 0.5rem;
                left: 0.5rem; /* Adjusted for mobile too */
            }
            #mini-map-container {
                width: 80px;
                height: 80px;
                top: 90px; /* Adjust based on new fuel gauge size */
                left: 0.5rem;
            }
            #mini-map-container svg {
                width: 70px;
                height: 70px;
            }
            #pip-container {
                width: 100px; /* Smaller PiP on mobile */
                height: 70px;
                top: 1rem;
                right: 1rem;
            }
            #pip-container::before {
                font-size: 0.5rem;
            }
            #joystick-controls {
                bottom: 6rem; /* Adjust for mobile */
                padding: 0 0.5rem;
            }
            .directional-button {
                width: 35px;
                height: 35px;
                font-size: 1rem;
                margin: 0.1rem;
            }
            #startup-screen .game-title-1989 {
                font-size: 1.8rem;
                letter-spacing: 0.1em;
            }
            #startup-screen .startup-button {
                padding: 1rem 2rem;
                font-size: 1.2rem;
            }
            #startup-screen .copyright-text {
                font-size: 0.7rem;
            }
        }
    </style>
</head>
<body>
    <div id="three-container"></div>

    <!-- Startup Screen -->
    <div id="startup-screen">
        <h2 class="game-title-1989">Dolumbican Blu Orbit</h2>
        <div class="startup-button-group">
            <button id="choose-default-craft" class="startup-button">Fly Default Craft</button>
            <button id="choose-glb-craft" class="startup-button">Fly Blu Orbit Craft</button>
        </div>
        <p class="copyright-text">© 1989 Dolumbican Studios Games. All Rights Reserved.</p>
    </div>


    <!-- New message box container -->
    <div id="mission-message-area" class="hidden">
        <div id="message-box">Awaiting Command...</div>
    </div>

    <!-- Main Game Title Container (Hidden until game starts) -->
    <div id="game-title-container" class="hidden">
        <h1 class="text-3xl md:text-5xl font-bold text-center text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-teal-400 drop-shadow-lg">
            Dolumbican Blu Orbit
        </h1>
    </div>

    <!-- Fuel Gauge Container (Hidden until game starts) -->
    <div id="fuel-gauge-container" class="hidden">
        <svg viewBox="0 0 100 100">
            <!-- Main Gauge Arc -->
            <path id="gauge-arc"
                  d="M 20 80 A 40 40 0 1 1 80 80"
                  fill="none" stroke="#00f0ff" stroke-width="3" stroke-linecap="round"/>

            <!-- Markers (adjusted for circular arc) -->
            <!-- E (Empty/Start) -->
            <text x="12" y="85" text-anchor="middle" fill="#00f0ff" font-size="8">E</text>
            <!-- 1/4 mark -->
            <text x="25" y="65" text-anchor="middle" fill="#00f0ff" font-size="8">1/4</text>
            <!-- 1/2 mark -->
            <text x="50" y="28" text-anchor="middle" fill="#00f0ff" font-size="8">1/2</text>
            <!-- 3/4 mark -->
            <text x="88" y="85" text-anchor="middle" fill="#00f0ff" font-size="8">F</text>

            <!-- Fuel Pump Icon (positioned at the bottom center of the gauge) -->
            <path id="fuel-pump-icon"
                  d="M50,70 L50,60 L55,60 L55,65 L60,65 L60,70 L50,70 Z M52.5,58 C51.5,58 50.5,59 50.5,60 L50.5,65 L49.5,65 L49.5,60 C49.5,59 48.5,58 47.5,58 L47.5,57 C48.5,57 49.5,57.5 49.5,58.5 L49.5,60 C49.5,61 50.5,62 51.5,62 Z"
                  transform="scale(0.5) translate(40, 105)"
                  />
            <circle cx="50" cy="50" r="4" fill="#00f0ff"/> <!-- Central pivot -->

            <!-- Needle/Lever (Now a simple line for explicit rotation) -->
            <line id="fuel-needle-line" x1="50" y1="50" x2="50" y2="20" stroke="#00ff00" stroke-width="2" stroke-linecap="round"/>

            <text x="50" y="95" text-anchor="middle" id="fuel-label">FUEL</text>
        </svg>
    </div>

    <!-- Mini-Map Container (Hidden until game starts) -->
    <div id="mini-map-container" class="hidden">
        <svg viewBox="0 0 100 100">
            <!-- Outer Ring -->
            <circle cx="50" cy="50" r="45" fill="none" stroke="#00f0ff" stroke-width="2" opacity="0.5"/>
            <!-- Inner Ring -->
            <circle cx="50" cy="50" r="25" fill="none" stroke="#00f0ff" stroke-width="1" opacity="0.3"/>
            <!-- Center Dot (Spacecraft) -->
            <circle cx="50" cy="50" r="3" fill="#ffffff"/>
            <!-- Dynamic Dots for Collectibles -->
            <g id="collectible-dots"></g>
            <text x="50" y="95" text-anchor="middle" id="mini-map-label">RADAR</text>
        </svg>
    </div>


    <div id="ui-container" class="hidden">
        <div id="health-bar-container">
            <!-- Health notches will be dynamically added here -->
        </div>

        <div id="control-panel-container">
            <div id="control-panel">
                <button id="main-power-button" class="retro-button">Main Power</button>
                <button id="engine-ignite-button" class="retro-button">Ignite Engines</button>
                <button id="thrust-control-button" class="retro-button">Thrust Control</button>
                <button id="view-toggle-button" class="retro-button">View</button>
                <button id="report-status-button" class="retro-button">Report Status</button>
                <button id="request-data-button" class="retro-button">Request Data</button>
            </div>
        </div>
    </div>
    <div id="pip-container" class="hidden"></div>

    <div id="joystick-controls" class="hidden">
        <div id="joystick-left" class="joystick-module">
            <button id="move-up" class="directional-button">▲</button>
            <div class="joystick-group-horizontal">
                <button id="move-left" class="directional-button">◀</button>
                <button id="move-down" class="directional-button">▼</button>
        </div>
        </div>
        <div id="joystick-right" class="joystick-module">
            <!-- This is for directional control right -->
            <button id="move-right" class="directional-button">▶</button>
        </div>
    </div>

    <!-- Loading Spinner -->
    <div id="loading-spinner"></div>

    <!-- Tone.js CDN for audio effects -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <!-- Three.js CDN -->
    <script type="module">
        // Import Three.js as a module - FIXED: Using full CDN URLs instead of bare specifiers
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js';
        // Import GLTFLoader explicitly as it's now a module
        import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/loaders/GLTFLoader.js';

        // Define __app_id and __firebase_config if not already defined (for local testing)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};

        // Main Three.js Scene Setup
        let scene, camera, renderer;
        let cockpitGroup; // Group to hold all cockpit elements for rotation
        let spacecraftMain; // Represents the physical spacecraft in the main scene (for chase/top views)
        let engineFireMain; // Fire effect for the main spacecraft in chase/top views
        let skybox;
        let ground;
        let panel3D;
        let cockpitFire; // Internal engine glow/fire for cockpit view
        let planets = []; // Array to hold planet meshes (non-collectible celestial bodies)

        // New GLB model variables for the custom spaceship
        let bluOrbitSpaceshipGLB = null;
        let bluOrbitSpaceshipPiP = null;

        // PiP Three.js Scene Setup
        let scenePiP, cameraPiP;
        // spacecraftPiP will be set after GLB load
        let engineFirePiP; // Fire effect for PiP spacecraft
        let skyboxPiP; // Skybox for PiP view
        let planetsPiP = [];

        let isFlying = false;
        // Removed autopilotActive as Autopilot button is removed
        let currentFlightSpeed = 0.5; // Made variable for Thrust Control
        const baseFlightSpeed = 0.5;
        const thrustBoostSpeed = 1.5; // Increased speed when thrust is active
        const maneuverSpeed = 0.1; // Speed for side/up/down movement
        const maxCockpitOffset = 2; // Max distance cockpit can move from center
        const maxCockpitTilt = 0.1; // Max rotation (radians) for banking

        // New variables for background speed control
        const skyboxSpeedMultiplier = 2.5; // Controls how fast the skybox moves
        const planetSpeedMultiplier = 0.2; // Controls how fast distant planets moves

        // Movement state for joystick/keyboard
        let moveX = 0; // -1 for left, 0 for none, 1 for right
        let moveY = 0; // -1 for down, 0 for none, 1 for up

        // Spacecraft Health System
        let maxHealth = 3;
        let spacecraftHealth = maxHealth;
        const healthBarContainer = document.getElementById('health-bar-container');

        // Mission Variables
        let distanceToEarth = 500000000; // Starting at 500 million miles
        let fuelLevel = 10000; // Starting with a good amount of fuel
        const maxFuelLevel = 10000; // Define max fuel level for gauge calculation
        const fuelConsumptionRate = 5; // Reduced fuel consumption rate
        const maneuverFuelCost = 0.5; // Reduced additional fuel cost for maneuvering
        const thrustFuelCostMultiplier = 2; // Reduced multiplier for fuel cost during thrust
        // Removed stabilizerFuelCost as Stabilizer button is removed
        // Removed stabilizerActive as Stabilizer button is removed

        // Removed currentCollectible as GLB models are gone
        // Removed all fuel tier system variables (isPremiumUser, freeRefillsUsed, maxFreeRefills, refuelCooldownActive, refuelCooldownStartTime, REFUEL_COOLDOWN_MS)
        // Removed malfunction state for low fuel (isMalfunctioning)
        // Removed debug mode variables (debugModeUses, maxDebugModeUses, isDebugModeActive, DEBUG_MODE_DURATION_MS)
        // Removed encounter spawn distances and related variables (UFO_SPAWN_DIST_MIN, UFO_SPAWN_DIST_MAX, UNKNOWN_CRAFT_SPAWN_DIST_MIN, UNKNOWN_CRAFT_SPAWN_DIST_MAX, ENCOUNTER_MESSAGE_COOLDOWN, lastUfoMessageTime, lastUnknownCraftMessageTime)
        // Removed ufoMesh, unknownCraftMesh, ufoSpawned, unknownCraftSpawned

        // Camera View Modes
        const VIEW_MODES = ['cockpit', 'posterior', 'horizontal']; // Updated view mode names
        let currentViewModeIndex = 0; // Start with cockpit view

        const messageBox = document.getElementById('message-box');
        const fuelNeedleLine = document.getElementById('fuel-needle-line'); // Reference to the needle SVG line
        // Removed hatchAnimationPopup and hatchAnimationMessage as Open Hatch and Debug buttons are removed
        const collectibleDotsGroup = document.getElementById('collectible-dots'); // SVG group for map dots
        const loadingSpinner = document.getElementById('loading-spinner');

        // Global references to buttons for easy access in any function
        let mainPowerButton;
        let engineIgniteButton;
        // Removed commLinkButton as Comm Link button is removed
        // Removed autopilotButton as Autopilot button is removed
        let thrustControlButton;
        // Removed debugModeButton as Debug Mode button is removed

        // URL for the new spaceship GLB model
        const SPACESHIP_GLB_URL = 'https://raw.githubusercontent.com/flixpear/bluorbit/main/157b45e4a6d8_A_spaceship_called_Blu_Orbit.glb';


        // Remove dynamic CSS for pulse-glow effect as relevant buttons are removed
        // const styleElement = document.createElement('style');
        // styleElement.innerHTML = `
        //     .retro-button.glow {
        //         animation: pulse-glow 1s infinite alternate;
        //     }
        //     @keyframes pulse-glow {
        //         from { box-shadow: 0 0 10px rgba(0, 255, 0, 0.5), inset 0 0 4px rgba(0, 255, 0, 0.3); }
        //         to { box-shadow: 0 0 20px rgba(0, 255, 0, 0.9), inset 0 0 8px rgba(0, 255, 0, 0.5); }
        //     }
        // `;
        // document.head.appendChild(styleElement);

        // --- Tone.js Audio Setup ---
        // It's good practice to resume the audio context on user interaction for mobile devices.
        document.documentElement.addEventListener("mousedown", () => {
          if (Tone.context.state !== 'running') {
            Tone.context.resume();
            console.log("Tone.js audio context resumed!");
          }
        });

        // Thrust Sound (for Main Power and Ignite Engines) - More "umph"
        // Chaining NoiseSynth through Distortion for a more aggressive sound
        const distortion = new Tone.Distortion(0.5).toDestination(); // Increased distortion
        const thrustEffect = new Tone.NoiseSynth({
            noise: {
                type: "white"
            },
            envelope: {
                attack: 0.1,  // Slightly longer attack for build-up
                decay: 1.0,   // Longer decay for "roar" tail
                sustain: 0,
                release: 0.5  // Longer release
            },
            volume: -3 // Louder
        }).connect(distortion); // Connect NoiseSynth to Distortion

        // Power Down Sound (for Thrust Control - when disengaged)
        const powerDownEffect = new Tone.Synth({
            oscillator: {
                type: "sine"
            },
            envelope: {
                attack: 0.01,
                decay: 0.5,
                sustain: 0,
                release: 0.1
            },
            volume: -10
        }).toDestination();

        // Function to play the thrust sound
        function playThrustSound() {
            thrustEffect.triggerAttackRelease("1n"); // Play for a full note duration for more presence
        }

        // Function to play the power down sound
        function playPowerDownSound() {
            const now = Tone.context.currentTime;
            powerDownEffect.triggerAttack(600, now);
            powerDownEffect.frequency.linearRampTo(100, 0.4, now + 0.01);
            powerDownEffect.triggerRelease(now + 0.5);
        }
        // --- End Tone.js Audio Setup ---


        // Function to update the fuel gauge visual
        function updateFuelGauge() {
            if (!fuelNeedleLine) return;

            const fuelPercentage = fuelLevel / maxFuelLevel;
            // Map fuelPercentage (0 to 1) to angle range (-135 to 135 degrees)
            const startAngle = -135; // Angle for 0% fuel (corresponds to E marker)
            const endAngle = 135;   // Angle for 100% fuel (corresponds to F marker)
            const angleRange = endAngle - startAngle;
            const currentAngle = startAngle + (fuelPercentage * angleRange);

            fuelNeedleLine.setAttribute('transform', `rotate(${currentAngle} 50 50)`);

            // Change needle color based on fuel level
            if (fuelPercentage > 0.6) {
                fuelNeedleLine.style.stroke = '#00ff00'; // Green
            } else if (fuelPercentage > 0.2) {
                fuelNeedleLine.style.stroke = '#ffcc00'; // Yellow
            } else {
                fuelNeedleLine.style.stroke = '#ff0000'; // Red
            }
        }

        // Function to create a stylized planet (for non-collectible celestial bodies)
        function createPlanet(radius, colorHex, type = 'rocky') {
            let planetMaterial;
            if (type === 'rocky') {
                planetMaterial = new THREE.MeshStandardMaterial({
                    color: colorHex,
                    metalness: 0.3,
                    roughness: 0.7,
                    flatShading: false // Smooth shading for planets
                });
            } else if (type === 'gas') {
                planetMaterial = new THREE.MeshPhongMaterial({
                    color: colorHex,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending,
                    emissive: colorHex,
                    emissiveIntensity: 0.15, // More subtle glow for gas
                    shininess: 50 // Adds a highlight
                });
            } else if (type === 'ice') {
                planetMaterial = new THREE.MeshStandardMaterial({
                    color: colorHex,
                    metalness: 0.7,
                    roughness: 0.2,
                    flatShading: false
                });
            }

            const planetGeometry = new THREE.SphereGeometry(radius, 64, 64); // Increased segments for smoother sphere
            const planet = new THREE.Mesh(planetGeometry, planetMaterial);
            planet.radius = radius; // Store radius for collision detection
            // Add rings to a "gas" planet for visual stunning effect
            if (type === 'gas') {
                const ringGeometry = new THREE.TorusGeometry(radius * 1.2, radius * 0.1, 2, 100);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0x8888aa, // Subtle ring color
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.6
                });
                const rings = new THREE.Mesh(ringGeometry, ringMaterial);
                rings.rotation.x = Math.PI / 2; // Flat on XY plane
                planet.add(rings); // Add rings as child of planet so they move with it
            }
            return planet;
        }

        // Function to create the engine fire mesh (reused for main and PiP)
        function createEngineFire() {
            const fireGeometry = new THREE.ConeGeometry(0.3, 1.5, 16);
            const fireMaterial = new THREE.MeshBasicMaterial({
                color: 0xffa500, // Orange
                transparent: true,
                opacity: 0.0, // Start invisible
                blending: THREE.AdditiveBlending,
                side: THREE.FrontSide
            });
            const fireMesh = new THREE.Mesh(fireGeometry, fireMaterial);
            fireMesh.rotation.x = -Math.PI / 2; // Point backwards (along positive Z in local space)
            return fireMesh;
        }

        // Function to load the main spaceship GLB model or create fallback
        function loadSpacecraftModel(craftType) {
            return new Promise((resolve, reject) => {
                // Remove existing spacecraft and fire elements if they exist
                if (bluOrbitSpaceshipGLB && bluOrbitSpaceshipGLB.parent) {
                    bluOrbitSpaceshipGLB.parent.remove(bluOrbitSpaceshipGLB);
                }
                if (bluOrbitSpaceshipPiP && bluOrbitSpaceshipPiP.parent) {
                    bluOrbitSpaceshipPiP.parent.remove(bluOrbitSpaceshipPiP);
                }

                if (craftType === 'glb') {
                    const loader = new GLTFLoader();
                    loader.load(SPACESHIP_GLB_URL, (gltf) => {
                        const model = gltf.scene;
                        console.log('GLB model loaded successfully:', model);

                        const initialBox = new THREE.Box3().setFromObject(model);
                        const initialSphere = new THREE.Sphere();
                        initialBox.getBoundingSphere(initialSphere);
                        console.log('Initial Bounding Box:', initialBox);
                        console.log('Initial Bounding Sphere Radius:', initialSphere.radius);

                        model.scale.set(0.5, 0.5, 0.5);
                        model.position.set(0, 0, 0);
                        model.rotation.y = Math.PI;

                        const finalBox = new THREE.Box3().setFromObject(model);
                        const finalSphere = new THREE.Sphere();
                        finalBox.getBoundingSphere(finalSphere);
                        model.radius = finalSphere.radius;
                        console.log('Final Bounding Box (after scaling/rotation):', finalBox);
                        console.log('Effective Collision Radius:', model.radius);

                        engineFireMain = createEngineFire();
                        engineFireMain.position.set(0, 0, finalBox.max.z + 0.5);
                        model.add(engineFireMain);

                        bluOrbitSpaceshipGLB = model;
                        scene.add(bluOrbitSpaceshipGLB);

                        bluOrbitSpaceshipPiP = model.clone();
                        bluOrbitSpaceshipPiP.scale.set(0.1, 0.1, 0.1);
                        bluOrbitSpaceshipPiP.position.set(0, 0, 0);
                        bluOrbitSpaceshipPiP.rotation.copy(model.rotation);

                        engineFirePiP = null;
                        bluOrbitSpaceshipPiP.traverse((child) => {
                            if (child.isMesh && child.geometry.type === 'ConeGeometry' && child.material.color.getHex() === 0xffa500) {
                                engineFirePiP = child;
                            }
                        });

                        if (!engineFirePiP) {
                            engineFirePiP = createEngineFire();
                            bluOrbitSpaceshipPiP.add(engineFirePiP);
                            const pipBox = new THREE.Box3().setFromObject(bluOrbitSpaceshipPiP);
                            engineFirePiP.position.set(0, 0, pipBox.max.z + 0.05);
                        } else {
                            const pipBox = new THREE.Box3().setFromObject(bluOrbitSpaceshipPiP);
                            engineFirePiP.position.set(0, 0, pipBox.max.z + 0.05);
                        }
                        scenePiP.add(bluOrbitSpaceshipPiP);
                        resolve();

                    }, undefined, (error) => {
                        console.error('Error loading GLB model:', SPACESHIP_GLB_URL, error);
                        displayMessage(`Mission Control: Failed to load Blu Orbit model. Using fallback Default Craft.`);
                        // Fallback to basic shape
                        spacecraftMain = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.6, 0.8, 3.5, 8),
                            new THREE.MeshPhongMaterial({ color: 0xe0e0e0, flatShading: true })
                        );
                        spacecraftMain.rotation.x = Math.PI / 2;
                        spacecraftMain.rotation.y = Math.PI;
                        spacecraftMain.position.set(0, 0, 0);
                        spacecraftMain.radius = 2.5;
                        scene.add(spacecraftMain);
                        bluOrbitSpaceshipGLB = spacecraftMain; // Assign fallback to bluOrbitSpaceshipGLB

                        bluOrbitSpaceshipPiP = spacecraftMain.clone();
                        bluOrbitSpaceshipPiP.scale.set(0.1, 0.1, 0.1);
                        scenePiP.add(bluOrbitSpaceshipPiP);

                        engineFireMain = createEngineFire();
                        engineFireMain.position.set(0, 0, -2.8);
                        spacecraftMain.add(engineFireMain);

                        engineFirePiP = createEngineFire();
                        engineFirePiP.position.set(0, 0, -0.28);
                        bluOrbitSpaceshipPiP.add(engineFirePiP);

                        resolve();
                    });
                } else { // 'default' craft chosen or GLB failed
                    spacecraftMain = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.6, 0.8, 3.5, 8),
                        new THREE.MeshPhongMaterial({ color: 0xe0e0e0, flatShading: true })
                    );
                    spacecraftMain.rotation.x = Math.PI / 2;
                    spacecraftMain.rotation.y = Math.PI;
                    spacecraftMain.position.set(0, 0, 0);
                    spacecraftMain.radius = 2.5;
                    scene.add(spacecraftMain);
                    bluOrbitSpaceshipGLB = spacecraftMain; // Assign fallback to bluOrbitSpaceshipGLB

                    bluOrbitSpaceshipPiP = spacecraftMain.clone();
                    bluOrbitSpaceshipPiP.scale.set(0.1, 0.1, 0.1);
                    scenePiP.add(bluOrbitSpaceshipPiP);

                    engineFireMain = createEngineFire();
                    engineFireMain.position.set(0, 0, -2.8);
                    spacecraftMain.add(engineFireMain);

                    engineFirePiP = createEngineFire();
                    engineFirePiP.position.set(0, 0, -0.28);
                    bluOrbitSpaceshipPiP.add(engineFirePiP);
                    resolve();
                }
            });
        }


        async function initThreeJS(craftType) {
            // Show loading spinner
            loadingSpinner.style.display = 'block';
            displayMessage("Mission Control: Initializing systems and loading assets. Please wait...");

            // --- Main Scene Setup ---
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x02020a);

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.5, 0); // Initial cockpit view position

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            // Append renderer.domElement to three-container only once during initial setup
            const threeContainer = document.getElementById('three-container');
            if (threeContainer.children.length === 0) { // Only add if not already present
                threeContainer.appendChild(renderer.domElement);
            }
            renderer.autoClear = false; // Important for rendering multiple scenes

            // Lighting for Main Scene
            const ambientLight = new THREE.AmbientLight(0x303030, 1);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight.position.set(10, 5, -15).normalize();
            scene.add(directionalLight);
            const pointLight = new THREE.PointLight(0x00f0ff, 0.3, 50, 2);
            pointLight.position.set(0, 1, -2);
            scene.add(pointLight);

            // Spacecraft Interior (Cockpit elements)
            cockpitGroup = new THREE.Group();
            scene.add(cockpitGroup);

            const interiorMaterial = new THREE.MeshStandardMaterial({
                color: 0x181820, metalness: 0.8, roughness: 0.3, side: THREE.BackSide
            });
            const cabinShape = new THREE.Shape();
            cabinShape.moveTo(-6, -2.5); cabinShape.lineTo(-5.5, 4); cabinShape.lineTo(5.5, 4); cabinShape.lineTo(6, -2.5);
            cabinShape.bezierCurveTo(6, -3, 3, -4, 0, -4.5); cabinShape.bezierCurveTo(-3, -4, -6, -3, -6, -2.5);
            const extrudeSettingsCabin = { steps: 1, depth: 12, bevelEnabled: true, bevelThickness: 0.2, bevelSize: 0.2, bevelOffset: 0, bevelSegments: 5 };
            const cabinMesh = new THREE.Mesh(new THREE.ExtrudeGeometry(cabinShape, extrudeSettingsCabin), interiorMaterial);
            cabinMesh.rotation.y = Math.PI; cabinMesh.position.set(0, 1.5, 6);
            cockpitGroup.add(cabinMesh);

            const windowFrameShape = new THREE.Shape();
            windowFrameShape.moveTo(-4.5, 3.5); windowFrameShape.lineTo(4.5, 3.5); windowFrameShape.lineTo(5.5, -1.5); windowFrameShape.lineTo(-5.5, -1.5); windowFrameShape.lineTo(-4.5, 3.5);
            const holePath = new THREE.Path();
            holePath.moveTo(-4, 3); holePath.lineTo(4, 3); holePath.lineTo(5, -1); holePath.lineTo(-5, -1); holePath.lineTo(-4, 3);
            windowFrameShape.holes.push(holePath);
            const extrudeSettingsWindow = { steps: 1, depth: 0.3, bevelEnabled: true, bevelThickness: 0.1, bevelSize: 0.1, bevelOffset: 0, bevelSegments: 4 };
            const windowFrameMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a25, metalness: 0.9, roughness: 0.2 });
            const windowFrame = new THREE.Mesh(new THREE.ExtrudeGeometry(windowFrameShape, extrudeSettingsWindow), windowFrameMaterial);
            windowFrame.position.set(0, 1.5, -5.8);
            cockpitGroup.add(windowFrame);

            const windowGlassGeometry = new THREE.PlaneGeometry(9, 4);
            const windowGlassMaterial = new THREE.MeshStandardMaterial({ color: 0x003366, transparent: true, opacity: 0.15, metalness: 0.1, roughness: 0.9, side: THREE.FrontSide });
            const windowGlass = new THREE.Mesh(windowGlassGeometry, windowGlassMaterial);
            windowGlass.position.set(0, 1.5, -5.7);
            cockpitGroup.add(windowGlass);

            // Control Panel 3D Model
            const panelMaterial = new THREE.MeshStandardMaterial({ color: 0x333340, metalness: 0.8, roughness: 0.3 });
            const panelBaseGeometry = new THREE.BoxGeometry(8, 0.8, 3);
            panel3D = new THREE.Mesh(panelBaseGeometry, panelMaterial);
            panel3D.position.set(0, -2, -1);
            cockpitGroup.add(panel3D);

            const panelFrontShape = new THREE.Shape();
            panelFrontShape.moveTo(-3.5, 0); panelFrontShape.lineTo(3.5, 0); panelFrontShape.lineTo(3.0, 0.7); panelFrontShape.lineTo(-3.0, 0.7); panelFrontShape.lineTo(-3.5, 0);
            const extrudeSettingsPanelFront = { steps: 1, depth: 0.4, bevelEnabled: true, bevelThickness: 0.08, bevelSize: 0.08, bevelOffset: 0, bevelSegments: 4 };
            const panelFront = new THREE.Mesh(new THREE.ExtrudeGeometry(panelFrontShape, extrudeSettingsPanelFront), panelMaterial);
            panelFront.rotation.x = -Math.PI / 8; panelFront.position.set(0, -1.5, -2.8);
            cockpitGroup.add(panelFront);

            const screenMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 0.3 });
            const indicatorLightMaterial = new THREE.MeshStandardMaterial({ color: 0xffa500, emissive: 0xffa500, emissiveIntensity: 0.5 });

            const recessedScreen1 = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.5, 0.1), screenMaterial);
            recessedScreen1.position.set(-1.5, -0.8, -2.9); recessedScreen1.rotation.x = -Math.PI / 8;
            cockpitGroup.add(recessedScreen1);
            const recessedScreen2 = recessedScreen1.clone();
            recessedScreen2.position.set(1.5, -0.8, -2.9);
            cockpitGroup.add(recessedScreen2);

            for (let i = 0; i < 4; i++) {
                const indicator = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.08, 16), indicatorLightMaterial);
                indicator.rotation.x = Math.PI / 2; indicator.position.set(-2.5 + i * 1.7, -1.2, -2.9);
                cockpitGroup.add(indicator);
            }

            // Engine Fire for cockpit view (still uses a simple mesh as internal visual effect)
            const cockpitFireGeometry = new THREE.ConeGeometry(0.5, 3, 32); // Slightly larger cone for internal effect
            const cockpitFireMaterial = new THREE.MeshBasicMaterial({
                color: 0xff7700, // More orange-red for fire
                transparent: true,
                opacity: 0.0, // Start invisible
                blending: THREE.AdditiveBlending
            });
            cockpitFire = new THREE.Mesh(cockpitFireGeometry, cockpitFireMaterial);
            cockpitFire.rotation.x = THREE.MathUtils.degToRad(90); // Use Three.js utility for degrees to radians
            cockpitFire.position.set(0, 0, 5); // Positioned to appear as if coming from rear of cockpit, behind the view
            cockpitGroup.add(cockpitFire);


            // --- PiP Scene Setup ---
            scenePiP = new THREE.Scene();
            cameraPiP = new THREE.PerspectiveCamera(60, 180 / 120, 0.1, 100); // Aspect ratio of PiP container, wider FOV
            cameraPiP.position.set(0, 0, 10); // Position directly behind for back view
            cameraPiP.lookAt(0, 0, 0); // Look at the origin where the spacecraft will be

            // PiP Light
            const pipAmbientLight = new THREE.AmbientLight(0x404040, 2);
            scenePiP.add(pipAmbientLight);
            const pipDirectionalLight = new THREE.DirectionalLight(0xffffff, 1);
            pipDirectionalLight.position.set(5, 5, 5).normalize();
            scenePiP.add(pipDirectionalLight);


            // Load the custom spaceship GLB for both main and PiP views
            await loadSpacecraftModel(craftType); // Call the updated loading function
            // After loading, spacecraftMain and spacecraftPiP are set.
            // Hide spinner and display ready message
            loadingSpinner.style.display = 'none';
            displayMessage("Mission Control: Systems initialized. Ready for Launch. Awaiting command.");


            // Deep Space Background (Skybox, stars, nebulas)
            skybox = new THREE.Mesh(
                new THREE.SphereGeometry(700, 64, 64),
                new THREE.MeshBasicMaterial({ color: 0x010105, side: THREE.BackSide })
            );
            scene.add(skybox);

            const starColors = [0xffffff, 0xaaaaff, 0xffffaa, 0xffaaff];
            for (let i = 0; i < 1500; i++) { // Slightly fewer stars for lighter feel
                const starRadius = Math.random() * 0.08 + 0.03; // Slightly smaller and lighter stars
                const starGeometry = new THREE.SphereGeometry(starRadius, 8, 8);
                const starMaterial = new THREE.MeshBasicMaterial({ color: starColors[Math.floor(Math.random() * starColors.length)] });
                const star = new THREE.Mesh(starGeometry, starMaterial);
                const r = 300 + Math.random() * 400; const theta = Math.random() * Math.PI * 2; const phi = Math.acos(Math.random() * 2 - 1);
                star.position.set(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
                skybox.add(star);
            }

            const nebulaColors = [0x5500aa, 0x0055ff, 0xaa00aa, 0xff00ff, 0x00ffff]; // More colors
            for (let i = 0; i < 10; i++) { // Fewer nebulas for lighter feel
                const nebulaSize = 50 + Math.random() * 100;
                const nebulaMaterial = new THREE.MeshBasicMaterial({
                    color: nebulaColors[Math.floor(Math.random() * nebulaColors.length)], transparent: true, opacity: 0.2 + Math.random() * 0.15, // Adjusted opacity
                    blending: THREE.AdditiveBlending, side: THREE.FrontSide
                });
                const nebula = new THREE.Mesh(new THREE.SphereGeometry(nebulaSize, 16, 16), nebulaMaterial);
                nebula.position.set((Math.random() - 0.5) * 800, (Math.random() - 0.5) * 800, -300 - Math.random() * 500);
                skybox.add(nebula);
            }

            // Planets (enhanced variety with more gas giants) - Initial random planets
            const planetTypes = [
                { radius: 50, color: 0x8B4513, type: 'rocky'},
                { radius: 70, color: 0x4682B4, type: 'gas'},
                { radius: 40, color: 0xADD8E6, type: 'ice'},
                { radius: 60, color: 0x773333, type: 'rocky'},
                { radius: 80, color: 0x8A2BE2, type: 'gas'},
                { radius: 35, color: 0xF0E68C, type: 'rocky'}
            ];

            for (let i = 0; i < 10; i++) {
                const data = planetTypes[i % planetTypes.length];
                const planet = createPlanet(data.radius + (Math.random() * 20 - 10), data.color, data.type);
                planet.position.set(
                    (Math.random() - 0.5) * 2500,
                    (Math.random() - 0.5) * 2500,
                    -1000 - Math.random() * 3000
                );
                scene.add(planet);
                planets.push(planet);
            }


            // Removed UFO Mesh and Unknown Craft Mesh creation
            // ufoMesh = null;
            // unknownCraftMesh = null;

            // Ground/Launch Pad
            ground = new THREE.Mesh(
                new THREE.PlaneGeometry(50, 50),
                new THREE.MeshStandardMaterial({ color: 0x444444, side: THREE.DoubleSide })
            );
            ground.rotation.x = THREE.MathUtils.degToRad(-90); ground.position.y = -2.5;
            scene.add(ground);


            // --- PiP Background Elements (Stars and Nebulae) ---
            skyboxPiP = new THREE.Mesh(
                new THREE.SphereGeometry(50, 32, 32), // Smaller sphere for PiP
                new THREE.MeshBasicMaterial({ color: 0x010105, side: THREE.BackSide })
            );
            scenePiP.add(skyboxPiP);

            // Add stars to PiP skybox (reusing the same starColors array)
            for (let i = 0; i < 75; i++) { // Fewer stars for PiP view
                const starRadius = Math.random() * 0.03 + 0.01;
                const starGeometry = new THREE.SphereGeometry(starRadius, 8, 8);
                const starMaterial = new THREE.MeshBasicMaterial({ color: starColors[Math.floor(Math.random() * starColors.length)] });
                const star = new THREE.Mesh(starGeometry, starMaterial);
                const r = 20 + Math.random() * 30;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                star.position.set(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
                skyboxPiP.add(star);
            }

            // Add nebulas to PiP skybox (reusing the same nebulaColors array)
            for (let i = 0; i < 1; i++) { // Fewer nebulas for PiP
                const nebulaSize = 10 + Math.random() * 20;
                const nebulaMaterial = new THREE.MeshBasicMaterial({
                    color: nebulaColors[Math.floor(Math.random() * nebulaColors.length)], transparent: true, opacity: 0.2 + Math.random() * 0.15,
                    blending: THREE.AdditiveBlending, side: THREE.FrontSide
                });
                const nebula = new THREE.Mesh(new THREE.SphereGeometry(nebulaSize, 16, 16), nebulaMaterial);
                nebula.position.set((Math.random() - 0.5) * 100, (Math.random() - 0.5) * 100, -50 - Math.random() * 50);
                skyboxPiP.add(nebula);
            }

            // PiP Planets (increased variety)
            for (let i = 0; i < 3; i++) { // Increased number of planets for PiP
                const data = planetTypes[i % planetTypes.length];
                const planet = createPlanet(data.radius / 5 + (Math.random() * 5 - 2.5), data.color, data.type); // Smaller and varied
                planet.position.set(
                    (Math.random() - 0.5) * 200,
                    (Math.random() - 0.5) * 200,
                    -100 - Math.random() * 200
                );
                scenePiP.add(planet);
                planetsPiP.push(planet);
            }


            // Mouse control for camera rotation (rotates the cockpit and background)
            let isMouseDown = false;
            let previousMouseX = 0;
            let previousMouseY = 0;

            document.addEventListener('mousedown', (event) => {
                // Only activate mouse control if not clicking on UI elements
                if (event.target.tagName === 'CANVAS') {
                    isMouseDown = true;
                    previousMouseX = event.clientX;
                    previousMouseY = event.clientY;
                }
            });

            document.addEventListener('mouseup', () => {
                isMouseDown = false;
            });

            document.addEventListener('mousemove', (event) => {
                if (!isMouseDown) return;

                const deltaX = event.clientX - previousMouseX;
                const deltaY = event.clientY - previousMouseY;

                // Rotate the entire cockpit group (including panel and window) and the skybox
                // This rotation behavior will only apply in 'cockpit' view.
                if (VIEW_MODES[currentViewModeIndex] === 'cockpit') {
                    cockpitGroup.rotation.y += deltaX * 0.002;
                    cockpitGroup.rotation.x += deltaY * 0.002;
                    cockpitGroup.rotation.x = Math.max(-Math.PI / 8, Math.min(Math.PI / 8, cockpitGroup.rotation.x));
                }
                // Always rotate the main skybox regardless of view mode
                skybox.rotation.y -= deltaX * 0.002;
                skybox.rotation.x -= deltaY * 0.002;

                previousMouseX = event.clientX;
                previousMouseY = event.clientY;
            });

            // Keyboard controls
            document.addEventListener('keydown', (event) => {
                if (!isFlying) return;
                switch (event.key) {
                    case 'ArrowLeft': moveX = -1; break;
                    case 'ArrowRight': moveX = 1; break;
                    case 'ArrowUp': moveY = 1; break;
                    case 'ArrowDown': moveY = -1; break;
                }
            });

            document.addEventListener('keyup', (event) => {
                if (!isFlying) return;
                switch (event.key) {
                    case 'ArrowLeft': if (moveX === -1) moveX = 0; break;
                    case 'ArrowRight': if (moveX === 1) moveX = 0; break;
                    case 'ArrowUp': if (moveY === 1) moveY = 0; break;
                    case 'ArrowDown': if (moveY === -1) moveY = 0; break;
                }
            });

            // Touch/Click listeners for joystick buttons
            const setupButtonMovement = (buttonId, xDir, yDir) => {
                const button = document.getElementById(buttonId);
                if (button) {
                    const startMove = () => {
                        if (isFlying) {
                            // Removed autopilotActive check
                            moveX = xDir;
                            moveY = yDir;
                        }
                    };
                    const stopMove = () => {
                        if (isFlying) {
                            if (moveX === xDir) moveX = 0;
                            if (moveY === yDir) moveY = 0;
                        }
                    };

                    button.addEventListener('mousedown', startMove);
                    button.addEventListener('mouseup', stopMove);
                    button.addEventListener('mouseleave', stopMove); // Stop if mouse leaves button while pressed

                    button.addEventListener('touchstart', (e) => {
                        e.preventDefault(); // Prevent scrolling on touch
                        startMove();
                    }, { passive: false });
                    button.addEventListener('touchend', stopMove);
                    button.addEventListener('touchcancel', stopMove);
                }
            };

            setupButtonMovement('move-left', -1, 0);
            setupButtonMovement('move-right', 1, 0);
            setupButtonMovement('move-up', 0, 1);
            setupButtonMovement('move-down', 0, -1);


            // Handle View Toggle Button
            document.getElementById('view-toggle-button').addEventListener('click', () => {
                currentViewModeIndex = (currentViewModeIndex + 1) % VIEW_MODES.length;
                updateCameraView();
                let viewName = "";
                switch(VIEW_MODES[currentViewModeIndex]) {
                    case 'cockpit': viewName = "Cockpit View"; break;
                    case 'posterior': viewName = "Posterior View"; break;
                    case 'horizontal': viewName = "Horizontal Flight View"; break;
                }
                displayMessage(`Mission Control: View changed to ${viewName}.`);
            });

            // Handle window resizing
            window.addEventListener('resize', onWindowResize, false);

            // Start the animation loop after everything is initialized
            animate();
        }

        // Function to update the main camera's view based on currentViewModeIndex
        function updateCameraView() {
            const currentMode = VIEW_MODES[currentViewModeIndex];

            // Reset initial positions/rotations for cockpitGroup and spacecraftMain
            // These resets are crucial to prevent accumulated rotations/positions from previous views.
            cockpitGroup.position.set(0, 1.5, 0);
            cockpitGroup.rotation.set(0, 0, 0);

            // Ensure spacecraftMain (GLB) is always at (0,0,0) of the world for camera targeting
            if (bluOrbitSpaceshipGLB) {
                 bluOrbitSpaceshipGLB.position.set(0, 0, 0);
                 bluOrbitSpaceshipGLB.rotation.y = Math.PI; // Reset to face -Z
            }


            // Hide/show elements based on view mode
            cockpitGroup.visible = (currentMode === 'cockpit');
            // Show main spacecraft (GLB) for chase/top views
            if (bluOrbitSpaceshipGLB) bluOrbitSpaceshipGLB.visible = (currentMode !== 'cockpit');
            if (bluOrbitSpaceshipPiP) bluOrbitSpaceshipPiP.visible = true; // PiP spacecraft is always visible when game is not exploded

            // Adjust camera and possibly spacecraft orientation based on view mode
            if (currentMode === 'cockpit') {
                camera.position.set(0, 1.5, 0); // Camera is fixed inside cockpit
                camera.rotation.set(0, 0, 0); // Camera does not rotate relative to world, only cockpitGroup
            } else if (currentMode === 'posterior') { // This is View #2 - Camera in front of the spacecraft, looking back at its tail and fire
                // Camera positioned directly behind the spacecraft, looking forward at its engines.
                camera.position.set(0, 2, 8); // Closer, slightly lower Y to be in line with engine
                camera.lookAt(0, 0, 0); // Still look at spacecraft's center (where GLB is)
            } else if (currentMode === 'horizontal') { // This is View #3 - Camera on LEFT, seeing fire from BACK-RIGHT
                // Camera positioned to the LEFT SIDE, slightly below, and a bit behind, to see the spacecraft's RIGHT REAR.
                camera.position.x = (bluOrbitSpaceshipGLB ? bluOrbitSpaceshipGLB.position.x : 0) - 10; // Moved to the left
                camera.position.y = (bluOrbitSpaceshipGLB ? bluOrbitSpaceshipGLB.position.y : 0) - 3;
                camera.position.z = (bluOrbitSpaceshipGLB ? bluOrbitSpaceshipGLB.position.z : 0) + 5;
                camera.lookAt(bluOrbitSpaceshipGLB ? bluOrbitSpaceshipGLB.position : new THREE.Vector3(0,0,0)); // Look at the spacecraft's current center
            }
        }


        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            // Update PiP camera aspect as well
            const pipContainer = document.getElementById('pip-container');
            const pipRect = pipContainer.getBoundingClientRect(); // Get position and size of PiP container
            const pixelRatio = renderer.getPixelRatio();

            const pipX = pipRect.left * pixelRatio;
            const pipY = (renderer.domElement.height - pipRect.bottom) * pixelRatio; // Y is from bottom for WebGL
            const pipWidth = pipRect.width * pixelRatio;
            const pipHeight = pipContainer.clientHeight * pixelRatio;

            renderer.setViewport(pipX, pipY, pipWidth, pipHeight);
            renderer.setScissor(pipX, pipY, pipWidth, pipHeight);
            renderer.setScissorTest(true); // Enable scissor test for PiP scene
            renderer.render(scenePiP, cameraPiP);
        }

        // Function to update health bar display
        function updateHealthDisplay() {
            healthBarContainer.innerHTML = ''; // Clear current notches
            for (let i = 0; i < maxHealth; i++) {
                const notch = document.createElement('div');
                notch.classList.add('health-notch');
                if (i >= spacecraftHealth) {
                    notch.style.backgroundColor = '#444'; // Grey for lost health
                    notch.style.boxShadow = 'none';
                } else if (spacecraftHealth === 1) {
                    notch.classList.add('critical');
                } else if (spacecraftHealth === 2) {
                    notch.classList.add('damaged');
                }
                healthBarContainer.appendChild(notch);
            }
        }

        // Handle collision function with health bar and removed autopilot logic
        function handleCollision(collidedObject) { // Renamed from collidedPlanet for clarity
            if (!isFlying) return;

            // If execution reaches here, it's a non-collectible obstacle
            spacecraftHealth--;
            updateHealthDisplay();
            displayMessage(`IMPACT! Hull integrity at ${spacecraftHealth}/${maxHealth}.`);

            // Removed autopilot disengage on collision

            // Reset position after hit, whether health is lost or not
            // Temporarily hide spacecraft during reset
            cockpitGroup.visible = false;
            if (bluOrbitSpaceshipGLB) bluOrbitSpaceshipGLB.visible = false;
            if (bluOrbitSpaceshipPiP) bluOrbitSpaceshipPiP.visible = false;


            if (spacecraftHealth <= 0) {
                displayMessage("CRITICAL FAILURE! Emergency reset initiated. System Rebooting...");
                isFlying = false; // Stop flight entirely
                // Removed autopilotActive reset
                // autopilotButton.textContent = 'Autopilot'; // Reset button text
                spacecraftHealth = maxHealth; // Reset health
                fuelLevel = maxFuelLevel; // Refuel on full system reset
            }


            setTimeout(() => {
                if (spacecraftHealth > 0) {
                    displayMessage("Hull repaired. Ready for manual re-engagement.");
                } else {
                    displayMessage("Systems rebooted. Ready for Launch. Awaiting command.");
                }
                // Reset spacecraft position for a fresh start, regardless of view mode
                cockpitGroup.position.set(0, 1.5, 0);
                cockpitGroup.rotation.set(0, 0, 0);
                if (bluOrbitSpaceshipGLB) {
                    bluOrbitSpaceshipGLB.position.set(0, 0, 0);
                    bluOrbitSpaceshipGLB.rotation.y = Math.PI; // Reset orientation
                }
                if (bluOrbitSpaceshipPiP) bluOrbitSpaceshipPiP.position.set(0, 0, 0); // Reset PiP spacecraft position

                // Make the appropriate spacecraft visible again based on current view
                updateCameraView();
                updateHealthDisplay(); // Ensure health display is accurate
                updateFuelGauge(); // Update fuel gauge display
            }, 1500); // Wait for a short moment before resetting / re-engaging
        }

        // Function to update the mini-map
        function updateMiniMap() {
            collectibleDotsGroup.innerHTML = ''; // Clear previous dots

            let currentSpacecraftPosition = new THREE.Vector3();
            if (VIEW_MODES[currentViewModeIndex] === 'cockpit') {
                cockpitGroup.getWorldPosition(currentSpacecraftPosition);
            } else {
                // Get world position of the loaded GLB model
                if (bluOrbitSpaceshipGLB) {
                    bluOrbitSpaceshipGLB.getWorldPosition(currentSpacecraftPosition);
                } else {
                    // Fallback if GLB not loaded, use dummy position
                    currentSpacecraftPosition.set(0,0,0);
                }
            }

            // Get the forward vector of the spacecraft
            const forwardVector = new THREE.Vector3();
            let spacecraftRotationY = 0;
            if (VIEW_MODES[currentViewModeIndex] === 'cockpit') {
                cockpitGroup.getWorldDirection(forwardVector);
                spacecraftRotationY = cockpitGroup.rotation.y;
            } else {
                if (bluOrbitSpaceshipGLB) {
                    bluOrbitSpaceshipGLB.getWorldDirection(forwardVector);
                    spacecraftRotationY = bluOrbitSpaceshipGLB.rotation.y;
                }
            }
            // Invert Z because positive Z is typically forward for objects, but camera looks -Z
            forwardVector.z *= -1; // Correct for camera orientation
            forwardVector.normalize();


            // Removed UFO and Unknown Craft radar dots logic
        }


        function animate() {
            requestAnimationFrame(animate);

            // Only update game elements if `renderer` exists and `isFlying` is true
            if (!renderer) { // Ensure renderer is initialized before proceeding with animation logic
                return;
            }

            // Rotate skybox slowly to give a sense of movement in space
            skybox.rotation.y += 0.00005;
            skybox.rotation.x += 0.00002;

            // Common fire animation values
            // Ensure cockpitFire, engineFireMain, engineFirePiP are initialized
            const fireOpacity = isFlying ? Math.min(0.8, (cockpitFire && cockpitFire.material.opacity || 0) + 0.05) : Math.max(0.0, (cockpitFire && cockpitFire.material.opacity || 0) - 0.05);
            const fireScalePulse = isFlying ? (0.5 + Math.sin(Date.now() * 0.02) * 0.2) : 0.0;
            const fireLengthPulse = isFlying ? (1.0 + Math.sin(Date.now() * 0.02) * 0.2) : 0.0;


            if (isFlying) {
                let fuelCost = fuelConsumptionRate;
                let intendedSpeed = baseFlightSpeed;
                if (thrustControlButton.textContent === 'Thrust (ON)') {
                    intendedSpeed = thrustBoostSpeed;
                }

                // Removed Malfunction logic for free tier when low on fuel
                // Removed isMalfunctioning logic
                currentFlightSpeed = intendedSpeed; // Set to full intended speed


                // Make fire visible when flying
                if (cockpitFire) cockpitFire.visible = true;
                if (engineFireMain) engineFireMain.visible = true;
                if (engineFirePiP) engineFirePiP.visible = true;


                // Removed Autopilot movement logic

                // Fuel cost calculation based on actual currentFlightSpeed
                if (currentFlightSpeed > baseFlightSpeed) { // Check if thrust is actually active
                    fuelCost *= thrustFuelCostMultiplier;
                }

                // Removed Stabilizer active fuel cost

                // Apply maneuvering fuel cost
                if (moveX !== 0 || moveY !== 0) {
                    fuelCost += maneuverFuelCost;
                }

                // Simple fuel consumption without premium tier logic
                if (fuelLevel <= 0) {
                    isFlying = false;
                    // Removed autopilotActive reset
                    // autopilotButton.textContent = 'Autopilot';
                    // Disable movement controls
                    moveX = 0;
                    moveY = 0;
                    // Hide fire immediately
                    if (cockpitFire) { cockpitFire.material.opacity = 0.0; cockpitFire.visible = false; }
                    if (engineFireMain) { engineFireMain.material.opacity = 0.0; engineFireMain.visible = false; }
                    if (engineFirePiP) { engineFirePiP.material.opacity = 0.0; engineFirePiP.visible = false; }

                    displayMessage("Mission Control: Warning! Fuel Depleted! Engage Main Power to refuel and restart engines."); // Standard refuel prompt
                    updateFuelGauge(); // Ensure gauge shows empty
                    return; // Stop further movement calculations for this frame
                } else {
                    fuelLevel -= fuelCost;
                    fuelLevel = Math.max(0, fuelLevel); // Ensure fuel doesn't go negative
                    updateFuelGauge(); // Update gauge every frame
                }


                // Determine what's moving based on view mode
                const currentMode = VIEW_MODES[currentViewModeIndex];

                // In all views, the "player" spacecraft (cockpitGroup or spacecraftMain) moves into negative Z.
                // Other objects (skybox, planets, UFOs, etc.) also move into negative Z relative to the world,
                // simulating being left behind by the player.
                if (currentMode === 'cockpit') {
                    cockpitGroup.position.z -= currentFlightSpeed;
                    // Apply maneuvering to cockpit
                    cockpitGroup.position.x += moveX * maneuverSpeed;
                    cockpitGroup.position.y += moveY * maneuverSpeed;
                    // Clamp cockpit position
                    cockpitGroup.position.x = Math.max(-maxCockpitOffset, Math.min(maxCockpitOffset, cockpitGroup.position.x));
                    cockpitGroup.position.y = Math.max(-maxCockpitOffset, Math.min(maxCockpitOffset, cockpitGroup.position.y));
                    // Apply banking rotation
                    const targetRoll = -moveX * maxCockpitTilt;
                    cockpitGroup.rotation.z += (targetRoll - cockpitGroup.rotation.z) * 0.1;
                    // The spacecraftMain (GLB) also needs to follow this movement for consistency
                    if (bluOrbitSpaceshipGLB) {
                        bluOrbitSpaceshipGLB.position.copy(cockpitGroup.position);
                        bluOrbitSpaceshipGLB.rotation.y = cockpitGroup.rotation.y + Math.PI; // Maintain relative rotation if cockpit rotates
                        bluOrbitSpaceshipGLB.rotation.x = cockpitGroup.rotation.x;
                        bluOrbitSpaceshipGLB.rotation.z = cockpitGroup.rotation.z;
                    }


                    // Cockpit Fire
                    if (cockpitFire) {
                        cockpitFire.material.opacity = fireOpacity;
                        cockpitFire.scale.x = cockpitFire.scale.y = fireScalePulse;
                        cockpitFire.scale.z = fireLengthPulse;
                    }

                } else { // Posterior/Horizontal views
                    // GLB Spaceship moves forward (into negative Z)
                    if (bluOrbitSpaceshipGLB) {
                        bluOrbitSpaceshipGLB.position.z -= currentFlightSpeed;
                        bluOrbitSpaceshipGLB.position.x += moveX * maneuverSpeed;
                        bluOrbitSpaceshipGLB.position.y += moveY * maneuverSpeed;
                        // Clamp spacecraftMain position
                        bluOrbitSpaceshipGLB.position.x = Math.max(-maxCockpitOffset, Math.min(maxCockpitOffset, bluOrbitSpaceshipGLB.position.x));
                        bluOrbitSpaceshipGLB.position.y = Math.max(-maxCockpitOffset, Math.min(maxCockpitOffset, bluOrbitSpaceshipGLB.position.y));
                        // Apply banking rotation to spacecraftMain
                        const targetRoll = -moveX * maxCockpitTilt;
                        bluOrbitSpaceshipGLB.rotation.z += (targetRoll - bluOrbitSpaceshipGLB.rotation.z) * 0.1;
                    }

                    // Main Engine Fire
                    if (engineFireMain) { // Ensure engineFireMain exists
                        engineFireMain.material.opacity = fireOpacity;
                        engineFireMain.scale.x = engineFireMain.scale.y = fireScalePulse;
                        engineFireMain.scale.z = fireLengthPulse;
                    }

                    // Camera follows or observes spacecraftMain (GLB)
                    if (currentMode === 'posterior') {
                        // Camera positioned directly behind the spacecraft, looking forward at its engines.
                        // Spacecraft tail is oriented to +Z due to its 180-degree Y rotation (set in loadSpacecraftGLB).
                        camera.position.x = bluOrbitSpaceshipGLB ? bluOrbitSpaceshipGLB.position.x : 0;
                        camera.position.y = (bluOrbitSpaceshipGLB ? bluOrbitSpaceshipGLB.position.y : 0) + 2; // Adjusted Y
                        camera.position.z = (bluOrbitSpaceshipGLB ? bluOrbitSpaceshipGLB.position.z : 0) + 8; // Adjusted Z
                        camera.lookAt(bluOrbitSpaceshipGLB ? bluOrbitSpaceshipGLB.position : new THREE.Vector3(0,0,0)); // Look at the spacecraft's current center
                    } else if (currentMode === 'horizontal') {
                        // Camera positioned to the LEFT SIDE, slightly below, and a bit behind, to see the spacecraft's RIGHT REAR.
                        camera.position.x = (bluOrbitSpaceshipGLB ? bluOrbitSpaceshipGLB.position.x : 0) - 10; // Moved to the left
                        camera.position.y = (bluOrbitSpaceshipGLB ? bluOrbitSpaceshipGLB.position.y : 0) - 3;
                        camera.position.z = (bluOrbitSpaceshipGLB ? bluOrbitSpaceshipGLB.position.z : 0) + 5;
                        camera.lookAt(bluOrbitSpaceshipGLB ? bluOrbitSpaceshipGLB.position : new THREE.Vector3(0,0,0)); // Look at the spacecraft's current center
                    }
                }

                // Update distance to Earth
                if (distanceToEarth > 0) {
                    distanceToEarth -= currentFlightSpeed * 100; // Arbitrary conversion for miles
                    distanceToEarth = Math.max(0, distanceToEarth);

                    // Removed UFO and Unknown Craft spawning logic


                    // Check for mission complete (no GLB Earth model for now, just end message)
                    if (distanceToEarth <= 0) { // Use <= 0 for safety margin
                        isFlying = false;
                        // Removed autopilotActive reset
                        displayMessage("MISSION COMPLETE! Dolumbican has returned to Earth. Well done, Commander! To learn more visit us at Dolumbican.com/");
                        return; // Stop further movement calculations for this frame
                    }
                }


                // Background movement: all elements not part of the player's craft move in -Z (away from camera)
                const mainSpacecraftCurrentZ = (bluOrbitSpaceshipGLB) ? bluOrbitSpaceshipGLB.position.z : cockpitGroup.position.z;

                skybox.position.z -= currentFlightSpeed * skyboxSpeedMultiplier;
                // If skybox moves too far behind, reset it to the front
                if (skybox.position.z < (mainSpacecraftCurrentZ - 700)) { // Reset relative to spacecraft's position
                    skybox.position.z = mainSpacecraftCurrentZ + 700; // Move it a full sphere diameter forward relative to spacecraft
                }

                // Planet movement and respawn/reset logic
                planets.forEach((planet) => {
                    if (planet.parent) { // Check if it's still in the scene
                        planet.position.z -= currentFlightSpeed * planetSpeedMultiplier; // Planets now move with the spacecraft (into -Z)

                        // If planet moves past camera (too far back), reset its position to the front
                        if (planet.position.z < (mainSpacecraftCurrentZ - 3000)) { // Reset when behind spacecraft and far away
                            planet.position.z = mainSpacecraftCurrentZ + 3000; // Reset to far front
                            planet.position.x = (Math.random() - 0.5) * 2500;
                            planet.position.y = (Math.random() - 0.5) * 2500;
                        }
                        planet.rotation.y += 0.001; // Slow rotation
                    }
                });


                // Removed UFO movement and messaging
                // Removed Unknown Craft movement and messaging


                // Collision Detection (Main Scene) - More robust collision detection
                let currentSpacecraftPosition = new THREE.Vector3();
                let spacecraftCollisionRadius = 2.5; // Default if GLB not loaded
                if (VIEW_MODES[currentViewModeIndex] === 'cockpit') {
                    cockpitGroup.getWorldPosition(currentSpacecraftPosition);
                } else {
                    if (bluOrbitSpaceshipGLB) {
                        bluOrbitSpaceshipGLB.getWorldPosition(currentSpacecraftPosition);
                        spacecraftCollisionRadius = bluOrbitSpaceshipGLB.radius * 0.4; // Use GLB's dynamic radius
                    }
                }


                // Check collision with non-collectible planets
                planets.forEach(planet => {
                    if (planet.parent) { // Check if it's still in the scene
                        const distance = currentSpacecraftPosition.distanceTo(planet.position);
                        const detectionRadius = spacecraftCollisionRadius + planet.radius * 0.9; // Adjusted for non-collectibles

                        if (distance < detectionRadius) {
                            handleCollision(planet);
                        }
                    }
                });


                // Main View: Rapidly move the ground down and out of view during initial takeoff
                if (ground.position.y < 100) {
                    ground.position.y += currentFlightSpeed * 2;
                    ground.material.opacity = Math.max(0, ground.material.opacity - 0.001);
                }

                // PiP View: Update spacecraft position (simulated forward movement)
                if (bluOrbitSpaceshipPiP) {
                    bluOrbitSpaceshipPiP.position.z -= currentFlightSpeed * 0.1; // Scale down movement for PiP
                    // Reset PiP spacecraft if it goes too far forward
                    if (bluOrbitSpaceshipPiP.position.z < -10) {
                        bluOrbitSpaceshipPiP.position.z = 0; // Reset to start of its journey
                    }
                }


                // PiP View: Move PiP skybox to simulate background passing
                skyboxPiP.position.z -= currentFlightSpeed * 0.1; // Consistent with main scene
                if (skyboxPiP.position.z < -50) skyboxPiP.position.z = 0; // Loop PiP skybox

                // PiP Planet movement
                planetsPiP.forEach(planet => {
                    planet.position.z -= currentFlightSpeed * 0.01; // Consistent with main scene
                    if (planet.position.z < -200) { // Reset when it moves past
                        planet.position.z = 100; // Reset to front
                        planet.position.x = (Math.random() - 0.5) * 200;
                        planet.position.y = (Math.random() - 0.5) * 200;
                    }
                    planet.rotation.y += 0.002;
                });

                // PiP Fire effect:
                if (engineFirePiP) {
                    engineFirePiP.material.opacity = fireOpacity;
                    engineFirePiP.scale.x = engineFirePiP.scale.y = fireScalePulse;
                    engineFirePiP.scale.z = fireLengthPulse;
                }

            } else {
                // Fade out all fire effects when not flying
                if (cockpitFire) { cockpitFire.material.opacity = Math.max(0.0, cockpitFire.material.opacity - 0.05); cockpitFire.visible = false; }
                if (engineFireMain) { engineFireMain.material.opacity = Math.max(0.0, engineFireMain.material.opacity - 0.05); engineFireMain.visible = false; }
                if (engineFirePiP) { engineFirePiP.material.opacity = Math.max(0.0, engineFirePiP.material.opacity - 0.05); engineFirePiP.visible = false; }


                // Return cockpit and main spacecraft to center when not flying
                cockpitGroup.position.x += (0 - cockpitGroup.position.x) * 0.05;
                cockpitGroup.position.y += (1.5 - cockpitGroup.position.y) * 0.05; // Return to initial Y
                cockpitGroup.rotation.z += (0 - cockpitGroup.rotation.z) * 0.05; // Return to no banking

                if (bluOrbitSpaceshipGLB) {
                    bluOrbitSpaceshipGLB.position.x += (0 - bluOrbitSpaceshipGLB.position.x) * 0.05;
                    bluOrbitSpaceshipGLB.position.y += (0 - bluOrbitSpaceshipGLB.position.y) * 0.05;
                    bluOrbitSpaceshipGLB.position.z += (0 - bluOrbitSpaceshipGLB.position.z) * 0.05;
                    bluOrbitSpaceshipGLB.rotation.z += (0 - bluOrbitSpaceshipGLB.rotation.z) * 0.05;
                    // Reset Y rotation if it was changed by camera movement in cockpit view
                    bluOrbitSpaceshipGLB.rotation.y += (Math.PI - bluOrbitSpaceshipGLB.rotation.y) * 0.05;
                }
            }

            updateMiniMap(); // Update mini-map every frame

            // Always render
            // --- Rendering multiple scenes ---
            renderer.clear(); // Clear the entire buffer

            // Render Main Scene
            renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
            renderer.setScissor(0, 0, window.innerWidth, window.innerHeight);
            renderer.setScissorTest(false); // Disable scissor test for main scene
            renderer.render(scene, camera);

            // Render PiP Scene
            const pipContainer = document.getElementById('pip-container');
            const pipRect = pipContainer.getBoundingClientRect(); // Get position and size of PiP container
            const pixelRatio = renderer.getPixelRatio();

            const pipX = pipRect.left * pixelRatio;
            const pipY = (renderer.domElement.height - pipRect.bottom) * pixelRatio; // Y is from bottom for WebGL
            const pipWidth = pipRect.width * pixelRatio;
            const pipHeight = pipContainer.clientHeight * pixelRatio;

            renderer.setViewport(pipX, pipY, pipWidth, pipHeight);
            renderer.setScissor(pipX, pipY, pipWidth, pipHeight);
            renderer.setScissorTest(true); // Enable scissor test for PiP scene
            renderer.render(scenePiP, cameraPiP);
        }

        // --- UI Interaction ---
        document.addEventListener('DOMContentLoaded', () => {
            const startupScreen = document.getElementById('startup-screen');
            const chooseDefaultBtn = document.getElementById('choose-default-craft');
            const chooseGlbBtn = document.getElementById('choose-glb-craft');

            // Hide game UI elements by default
            const gameUIElements = [
                document.getElementById('mission-message-area'),
                document.getElementById('game-title-container'),
                document.getElementById('fuel-gauge-container'),
                document.getElementById('mini-map-container'),
                document.getElementById('ui-container'),
                document.getElementById('pip-container'),
                document.getElementById('joystick-controls')
            ];
            gameUIElements.forEach(el => el.classList.add('hidden'));
            document.getElementById('loading-spinner').style.display = 'none'; // Ensure spinner is off initially

            // Set up global references to buttons
            mainPowerButton = document.getElementById('main-power-button');
            engineIgniteButton = document.getElementById('engine-ignite-button');
            thrustControlButton = document.getElementById('thrust-control-button');


            const startGame = async (craftType) => {
                startupScreen.classList.add('hidden'); // Hide the startup screen
                document.getElementById('loading-spinner').style.display = 'block'; // Show spinner

                // Initialize Three.js scene with selected craft
                await initThreeJS(craftType); // This is async and returns a promise
                document.getElementById('loading-spinner').style.display = 'none'; // Hide spinner

                // Show all game UI elements after initialization
                gameUIElements.forEach(el => el.classList.remove('hidden'));

                // Initialize display for dynamic UI elements
                updateHealthDisplay();
                updateFuelGauge();
                displayMessage("Mission Control: Systems initialized. Ready for Launch. Awaiting command.");
            };

            chooseDefaultBtn.addEventListener('click', () => startGame('default'));
            chooseGlbBtn.addEventListener('click', () => startGame('glb'));


            document.querySelectorAll('.retro-button').forEach(button => {
                button.addEventListener('click', () => {
                    const buttonText = button.textContent;
                    let message = '';
                    switch (button.id) {
                        case 'main-power-button':
                            playThrustSound(); // Play thrust sound
                            fuelLevel = maxFuelLevel; // Refuel to max
                            message = `Main Power: ONLINE! Systems initializing... Fuel replenished!`;
                            displayMessage(message);
                            updateFuelGauge();

                            setTimeout(() => {
                                displayMessage("Mission Control: Command Control to Dolumbican - Ignite Engines!");
                            }, 1000); // 1 second delay
                            break;
                        case 'engine-ignite-button':
                            playThrustSound(); // Play thrust sound
                            if (fuelLevel <= 0 && !isFlying) {
                                message = 'FUEL CRITICAL! Cannot ignite engines. Replenish fuel first (Main Power button).';
                            } else {
                                isFlying = !isFlying; // Toggle flight state
                                if (isFlying) {
                                    message = 'Engine Ignition Sequence: Initiated! Blast off!';
                                    // Reset ground for new takeoff if it's already gone
                                    ground.position.y = -2.5;
                                    ground.material.opacity = 1.0;
                                    if (spacecraftHealth <= 0) { // If starting flight with 0 health, reset health
                                        spacecraftHealth = maxHealth;
                                        updateHealthDisplay();
                                    }
                                } else {
                                    message = 'Engines Shut Down. Cruising at current velocity.';
                                    // Reset movement state when flight stops
                                    moveX = 0;
                                    moveY = 0;
                                    currentFlightSpeed = baseFlightSpeed;
                                    thrustControlButton.textContent = 'Thrust Control';
                                }
                            }
                            updateCameraView(); // Ensure camera is correctly positioned after flight state change
                            break;
                        case 'thrust-control-button':
                            if (isFlying) {
                                if (button.textContent === 'Thrust Control' || button.textContent === 'Thrust (OFF)') { // Simplified toggle
                                    playThrustSound(); // Play thrust sound when engaging thrust
                                    currentFlightSpeed = thrustBoostSpeed;
                                    message = 'Thrust Boost: Engaged! Increased fuel consumption.';
                                    button.textContent = 'Thrust (ON)';
                                } else {
                                    playPowerDownSound(); // Play power down sound when disengaging thrust
                                    currentFlightSpeed = baseFlightSpeed;
                                    message = 'Thrust Boost: Disengaged. Returning to normal speed.';
                                    button.textContent = 'Thrust Control';
                                }
                            } else {
                                message = 'Thrust control requires engines to be ignited.';
                            }
                            break;
                        case 'view-toggle-button':
                            // Handled by event listener outside this switch
                            break;
                        case 'report-status-button':
                            message = `Mission Control: Dolumbican reporting. Status: Health ${spacecraftHealth}/${maxHealth}, Flight: ${isFlying ? 'Active' : 'Idle'}. Fuel: ${fuelLevel.toFixed(0)}/${maxFuelLevel}.`;
                            break;
                        case 'request-data-button':
                            message = `Mission Control: Data Packet. Miles to Earth: ${distanceToEarth.toLocaleString()} miles. Fuel: ${fuelLevel.toFixed(0)}.`;
                            break;
                        default:
                            message = `Button "${buttonText}" pressed!`;
                    }
                    displayMessage(message);
                });
            });

        }); // End DOMContentLoaded


        function displayMessage(message) {
            messageBox.textContent = message;
            // Optional: Clear message after a few seconds
            // setTimeout(() => {
            //     messageBox.textContent = 'Awaiting Command...';
            // }, 5000);
        }
    </script>
</body>
</html>